{"version":3,"sources":["node_modules/browser-pack/_prelude.js","assert-mock.js","find-my-way.min.js","custom_node.js","handler_storage.js","index.js","lib/constrainer.js","lib/http-methods.js","lib/pretty-print.js","lib/strategies/accept-host.js","lib/strategies/accept-version.js","lib/url-sanitizer.js","node_modules/fast-decode-uri-component/index.js","node_modules/fast-deep-equal/index.js","node_modules/fast-querystring/lib/index.js","node_modules/fast-querystring/lib/internals/querystring.js","node_modules/fast-querystring/lib/parse.js","node_modules/fast-querystring/lib/stringify.js","node_modules/ret/lib/index.js","node_modules/ret/lib/positions.js","node_modules/ret/lib/sets.js","node_modules/ret/lib/types.js","node_modules/ret/lib/util.js","node_modules/safe-regex2/index.js"],"names":["f","exports","module","define","amd","window","global","self","this","FindMyWay","r","e","n","t","o","i","c","require","u","a","Error","code","p","call","length","expr","message","HandlerStorage","NODE_TYPES","STATIC","PARAMETRIC","WILDCARD","Node","constructor","handlerStorage","ParentNode","super","staticChildren","findStaticMatchingChild","path","pathIndex","staticChild","charAt","undefined","matchPrefix","createStaticChild","prefix","charCodeAt","split","slice","label","StaticNode","wildcardChild","parametricChildren","kind","_compilePrefixMatch","createParametricChild","regex","staticSuffix","regexpSource","source","parametricChild","find","child","ParametricNode","push","sort","child1","child2","isRegex","endsWith","createWildcardChild","WildcardNode","parentNode","parentPrefix","childPrefix","staticNode","getNextNode","nodeStack","paramsCount","node","parametricBrotherNodeIndex","brotherPathIndex","brotherNode","lines","charCode","Function","join","unconstrainedHandler","constraints","handlers","constrainedHandlerStores","getMatchingHandler","derivedConstraints","_getHandlerMatchingConstraints","addHandler","handler","params","store","constrainer","handlerObject","_createParamsObject","_compileCreateParamsObject","Object","keys","constraint","includes","unshift","b","_compileGetHandlerMatchingConstraints","_buildConstraintStore","constraintValue","indexes","get","set","_constrainedIndexBitmask","mask","newStoreForConstraint","matchMask","strategies","mustMatchWhenDerived","assert","querystring","isRegexSafe","deepEqual","flattenNode","compressFlattenedNode","prettyPrintFlattenedNode","prettyPrintRoutesArray","Constrainer","httpMethods","safeDecodeURI","safeDecodeURIComponent","FULL_PATH_REGEXP","OPTIONAL_PARAM_REGEXP","Router","opts","defaultRoute","onBadUrl","buildPrettyMeta","defaultBuildPrettyMeta","querystringParser","query","parse","caseSensitive","ignoreTrailingSlash","ignoreDuplicateSlashes","maxParamLength","allowUnsafeRegex","routes","trees","_routesPatterns","prototype","on","method","optionalParamMatch","match","index","pathFull","replace","pathOptional","route","removeDuplicateSlashes","trimLastSlash","methods","Array","isArray","_on","validateConstraints","noteUsage","currentRoot","currentNode","parentNodePathIndex","isParametricNode","isWildcardNode","staticNodePath","toLowerCase","isRegexNode","regexps","lastParamStartIndex","j","isRegexParam","isStaticPart","isEndOfNode","paramName","endOfRegexIndex","getClosingParenthensePosition","regexString","RegExp","trimRegExpStartAndEnd","staticPartStartIndex","staticPart","nodePattern","existRoute","JSON","stringify","hasConstraintStrategy","strategyName","addConstraintStrategy","_rebuild","reset","off","_off","matcherWithoutConstraints","predicate","newRoutes","filter","lookup","req","res","ctx","done","deriveConstraints","handle","url","callHandler","err","result","_defaultRoute","searchParams","sanitizedUrl","shouldDecodeParam","error","_onBadUrl","originPath","pathLen","brothersNodesStack","brotherNodeState","pop","splice","paramEndIndex","indexOf","param","matchedParameters","exec","matchedParam","statusCode","end","prettyPrint","commonPrefix","root","nodes","children","hasOwnProperty","m","methodName","idx","parentheses","TypeError","assign","all","acceptVersionStrategy","acceptHostStrategy","customStrategies","version","host","strategiesInUse","Set","asyncStrategiesInUse","strategy","values","isStrategyUsed","has","customConstraintStrategy","isCustom","name","storage","deriveConstraint","isAsync","deriveSyncConstraints","deriveAsyncConstraints","beforeSize","size","key","add","_buildDeriveConstraints","value","validate","asyncConstraintsCount","bind","indent","branchIndent","midBranchIndent","endBranchIndent","wildcardDelimiter","pathDelimiter","pathRegExp","parseMeta","meta","map","toString","fn","fName","trim","parseFunctionName","buildMetaObject","metaArray","out","cleanMeta","Reflect","ownKeys","forEach","metaKey","drawBranch","pathSeg","endBranch","noPrefix","rootBranch","branch","flatHandlers","reduce","acc","curr","findIndex","h","hidx","skipPrefix","flattened","childPrefixSegments","parent","cursor","segment","flattenedNode","childKeys","tail","includeMeta","printHandlers","suffix","paramIndices","ch","prevLoc","loc","tree","labels","routeArray","mergedRouteArray","localeCompare","pathExists","routeHandler","rootPath","truncatedPath","routeTree","temp","splitPath","pidx","buildRouteTree","hosts","regexHosts","exact","test","SemVerStore","maxMajor","maxMinors","maxPatches","major","minor","patch","Number","x","decodeComponentChar","highCharCode","lowCharCode","shouldDecode","decodeURI","uriComponent","startIndex","decoded","lastIndex","decodedChar","UTF8_ACCEPT","UTF8_REJECT","UTF8_DATA","HEX","A","B","C","d","D","E","F","hexCodeToInt","shift","uri","percentPosition","last","codepoint","startOfOctets","state","byte","type","String","fromCharCode","equal","flags","valueOf","fastQuerystring","default","hexTable","from","_","toUpperCase","noEscape","Int8Array","encodeString","str","len","lastPos","outer","fastDecode","plusRegex","Empty","create","input","inputLength","startingIndex","equalityIndex","shouldDecodeKey","shouldDecodeValue","keyHasPlus","valueHasPlus","hasBothKeyValuePair","currentValue","getAsPrimitive","isFinite","keyLength","valueLength","encodedKey","util","types","sets","positions","regexpStr","l","start","ROOT","stack","lastGroup","groupStack","repeatErr","strToChars","wordBoundary","nonWordBoundary","words","notWords","ints","notInts","whitespace","notWhitespace","REFERENCE","parseInt","CHAR","begin","not","classTokens","tokenizeClass","SET","anyChar","group","GROUP","remember","followedBy","notFollowedBy","options","min","max","rs","Infinity","REPETITION","POSITION","INTS","RANGE","to","WORDS","concat","WHITESPACE","SLSH","v","s","lbs","a16","b16","c8","dctrl","eslsh","tokens","regexp","msg","SyntaxError","re","replimit","limit","reps","walk","starHeight","ret"],"mappings":"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A,EAAA,EACA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EACA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EACA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EACA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EACA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EACA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EACA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EACA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EACA,GAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAIA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EACA,GAAA,EAAA,EAAA,EAAA,EAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GACA,EAAA,GAAA,GAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EACA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EACA,EAAA,GAAA,GAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EACA,EAAA,GAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EACA,EAAA,GAAA,GAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EACA,EAAA,EAAA,GAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAA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","file":"find-my-way.min.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","'use strict'\n\nfunction Assert (expr, message) {\n  if (!expr) {\n    throw new Error(message)\n  }\n\n  return true\n}\n\nmodule.exports = Assert\n","(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.FindMyWay = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){\n'use strict'\n\nfunction Assert (expr, message) {\n  if (!expr) {\n    throw new Error(message)\n  }\n\n  return true\n}\n\nmodule.exports = Assert\n\n},{}],2:[function(require,module,exports){\n'use strict'\n\nconst HandlerStorage = require('./handler_storage')\n\nconst NODE_TYPES = {\n  STATIC: 0,\n  PARAMETRIC: 1,\n  WILDCARD: 2\n}\n\nclass Node {\n  constructor () {\n    this.handlerStorage = new HandlerStorage()\n  }\n}\n\nclass ParentNode extends Node {\n  constructor () {\n    super()\n    this.staticChildren = {}\n  }\n\n  findStaticMatchingChild (path, pathIndex) {\n    const staticChild = this.staticChildren[path.charAt(pathIndex)]\n    if (staticChild === undefined || !staticChild.matchPrefix(path, pathIndex)) {\n      return null\n    }\n    return staticChild\n  }\n\n  createStaticChild (path) {\n    if (path.length === 0) {\n      return this\n    }\n\n    let staticChild = this.staticChildren[path.charAt(0)]\n    if (staticChild) {\n      let i = 1\n      for (; i < staticChild.prefix.length; i++) {\n        if (path.charCodeAt(i) !== staticChild.prefix.charCodeAt(i)) {\n          staticChild = staticChild.split(this, i)\n          break\n        }\n      }\n      return staticChild.createStaticChild(path.slice(i))\n    }\n\n    const label = path.charAt(0)\n    this.staticChildren[label] = new StaticNode(path)\n    return this.staticChildren[label]\n  }\n}\n\nclass StaticNode extends ParentNode {\n  constructor (prefix) {\n    super()\n    this.prefix = prefix\n    this.wildcardChild = null\n    this.parametricChildren = []\n    this.kind = NODE_TYPES.STATIC\n    this._compilePrefixMatch()\n  }\n\n  createParametricChild (regex, staticSuffix) {\n    const regexpSource = regex && regex.source\n\n    let parametricChild = this.parametricChildren.find(child => {\n      const childRegexSource = child.regex && child.regex.source\n      return childRegexSource === regexpSource\n    })\n\n    if (parametricChild) {\n      return parametricChild\n    }\n\n    parametricChild = new ParametricNode(regex, staticSuffix)\n    this.parametricChildren.push(parametricChild)\n    this.parametricChildren.sort((child1, child2) => {\n      if (!child1.isRegex) return 1\n      if (!child2.isRegex) return -1\n\n      if (child1.staticSuffix === null) return 1\n      if (child2.staticSuffix === null) return -1\n\n      if (child2.staticSuffix.endsWith(child1.staticSuffix)) return 1\n      if (child1.staticSuffix.endsWith(child2.staticSuffix)) return -1\n\n      return 0\n    })\n\n    return parametricChild\n  }\n\n  createWildcardChild () {\n    if (this.wildcardChild) {\n      return this.wildcardChild\n    }\n\n    this.wildcardChild = new WildcardNode()\n    return this.wildcardChild\n  }\n\n  split (parentNode, length) {\n    const parentPrefix = this.prefix.slice(0, length)\n    const childPrefix = this.prefix.slice(length)\n\n    this.prefix = childPrefix\n    this._compilePrefixMatch()\n\n    const staticNode = new StaticNode(parentPrefix)\n    staticNode.staticChildren[childPrefix.charAt(0)] = this\n    parentNode.staticChildren[parentPrefix.charAt(0)] = staticNode\n\n    return staticNode\n  }\n\n  getNextNode (path, pathIndex, nodeStack, paramsCount) {\n    let node = this.findStaticMatchingChild(path, pathIndex)\n    let parametricBrotherNodeIndex = 0\n\n    if (node === null) {\n      if (this.parametricChildren.length === 0) {\n        return this.wildcardChild\n      }\n\n      node = this.parametricChildren[0]\n      parametricBrotherNodeIndex = 1\n    }\n\n    if (this.wildcardChild !== null) {\n      nodeStack.push({\n        paramsCount,\n        brotherPathIndex: pathIndex,\n        brotherNode: this.wildcardChild\n      })\n    }\n\n    for (let i = this.parametricChildren.length - 1; i >= parametricBrotherNodeIndex; i--) {\n      nodeStack.push({\n        paramsCount,\n        brotherPathIndex: pathIndex,\n        brotherNode: this.parametricChildren[i]\n      })\n    }\n\n    return node\n  }\n\n  _compilePrefixMatch () {\n    if (this.prefix.length === 1) {\n      this.matchPrefix = () => true\n      return\n    }\n\n    const lines = []\n    for (let i = 1; i < this.prefix.length; i++) {\n      const charCode = this.prefix.charCodeAt(i)\n      lines.push(`path.charCodeAt(i + ${i}) === ${charCode}`)\n    }\n    this.matchPrefix = new Function('path', 'i', `return ${lines.join(' && ')}`) // eslint-disable-line\n  }\n}\n\nclass ParametricNode extends ParentNode {\n  constructor (regex, staticSuffix) {\n    super()\n    this.isRegex = !!regex\n    this.regex = regex || null\n    this.staticSuffix = staticSuffix || null\n    this.kind = NODE_TYPES.PARAMETRIC\n  }\n\n  getNextNode (path, pathIndex) {\n    return this.findStaticMatchingChild(path, pathIndex)\n  }\n}\n\nclass WildcardNode extends Node {\n  constructor () {\n    super()\n    this.kind = NODE_TYPES.WILDCARD\n  }\n\n  getNextNode () {\n    return null\n  }\n}\n\nmodule.exports = { StaticNode, ParametricNode, WildcardNode, NODE_TYPES }\n\n},{\"./handler_storage\":3}],3:[function(require,module,exports){\n'use strict'\n\nclass HandlerStorage {\n  constructor () {\n    this.unconstrainedHandler = null // optimized reference to the handler that will match most of the time\n    this.constraints = []\n    this.handlers = [] // unoptimized list of handler objects for which the fast matcher function will be compiled\n    this.constrainedHandlerStores = null\n  }\n\n  // This is the hot path for node handler finding -- change with care!\n  getMatchingHandler (derivedConstraints) {\n    if (derivedConstraints === undefined) {\n      return this.unconstrainedHandler\n    }\n    return this._getHandlerMatchingConstraints(derivedConstraints)\n  }\n\n  addHandler (handler, params, store, constrainer, constraints) {\n    const handlerObject = {\n      handler,\n      params,\n      constraints,\n      store: store || null,\n      _createParamsObject: this._compileCreateParamsObject(params)\n    }\n\n    if (Object.keys(constraints).length === 0) {\n      this.unconstrainedHandler = handlerObject\n    }\n\n    for (const constraint of Object.keys(constraints)) {\n      if (!this.constraints.includes(constraint)) {\n        if (constraint === 'version') {\n          // always check the version constraint first as it is the most selective\n          this.constraints.unshift(constraint)\n        } else {\n          this.constraints.push(constraint)\n        }\n      }\n    }\n\n    if (this.handlers.length >= 32) {\n      throw new Error('find-my-way supports a maximum of 32 route handlers per node when there are constraints, limit reached')\n    }\n\n    this.handlers.push(handlerObject)\n    // Sort the most constrained handlers to the front of the list of handlers so they are tested first.\n    this.handlers.sort((a, b) => Object.keys(a.constraints).length - Object.keys(b.constraints).length)\n\n    this._compileGetHandlerMatchingConstraints(constrainer, constraints)\n  }\n\n  _compileCreateParamsObject (params) {\n    const lines = []\n    for (let i = 0; i < params.length; i++) {\n      lines.push(`'${params[i]}': paramsArray[${i}]`)\n    }\n    return new Function('paramsArray', `return {${lines.join(',')}}`)  // eslint-disable-line\n  }\n\n  _getHandlerMatchingConstraints () {\n    return null\n  }\n\n  // Builds a store object that maps from constraint values to a bitmap of handler indexes which pass the constraint for a value\n  // So for a host constraint, this might look like { \"fastify.io\": 0b0010, \"google.ca\": 0b0101 }, meaning the 3rd handler is constrainted to fastify.io, and the 2nd and 4th handlers are constrained to google.ca.\n  // The store's implementation comes from the strategies provided to the Router.\n  _buildConstraintStore (store, constraint) {\n    for (let i = 0; i < this.handlers.length; i++) {\n      const handler = this.handlers[i]\n      const constraintValue = handler.constraints[constraint]\n      if (constraintValue !== undefined) {\n        let indexes = store.get(constraintValue) || 0\n        indexes |= 1 << i // set the i-th bit for the mask because this handler is constrained by this value https://stackoverflow.com/questions/1436438/how-do-you-set-clear-and-toggle-a-single-bit-in-javascrip\n        store.set(constraintValue, indexes)\n      }\n    }\n  }\n\n  // Builds a bitmask for a given constraint that has a bit for each handler index that is 0 when that handler *is* constrained and 1 when the handler *isnt* constrainted. This is opposite to what might be obvious, but is just for convienience when doing the bitwise operations.\n  _constrainedIndexBitmask (constraint) {\n    let mask = 0\n    for (let i = 0; i < this.handlers.length; i++) {\n      const handler = this.handlers[i]\n      const constraintValue = handler.constraints[constraint]\n      if (constraintValue !== undefined) {\n        mask |= 1 << i\n      }\n    }\n    return ~mask\n  }\n\n  // Compile a fast function to match the handlers for this node\n  // The function implements a general case multi-constraint matching algorithm.\n  // The general idea is this: we have a bunch of handlers, each with a potentially different set of constraints, and sometimes none at all. We're given a list of constraint values and we have to use the constraint-value-comparison strategies to see which handlers match the constraint values passed in.\n  // We do this by asking each constraint store which handler indexes match the given constraint value for each store. Trickily, the handlers that a store says match are the handlers constrained by that store, but handlers that aren't constrained at all by that store could still match just fine. So, each constraint store can only describe matches for it, and it won't have any bearing on the handlers it doesn't care about. For this reason, we have to ask each stores which handlers match and track which have been matched (or not cared about) by all of them.\n  // We use bitmaps to represent these lists of matches so we can use bitwise operations to implement this efficiently. Bitmaps are cheap to allocate, let us implement this masking behaviour in one CPU instruction, and are quite compact in memory. We start with a bitmap set to all 1s representing every handler that is a match candidate, and then for each constraint, see which handlers match using the store, and then mask the result by the mask of handlers that that store applies to, and bitwise AND with the candidate list. Phew.\n  // We consider all this compiling function complexity to be worth it, because the naive implementation that just loops over the handlers asking which stores match is quite a bit slower.\n  _compileGetHandlerMatchingConstraints (constrainer) {\n    this.constrainedHandlerStores = {}\n\n    for (const constraint of this.constraints) {\n      const store = constrainer.newStoreForConstraint(constraint)\n      this.constrainedHandlerStores[constraint] = store\n\n      this._buildConstraintStore(store, constraint)\n    }\n\n    const lines = []\n    lines.push(`\n    let candidates = ${(1 << this.handlers.length) - 1}\n    let mask, matches\n    `)\n    for (const constraint of this.constraints) {\n      // Setup the mask for indexes this constraint applies to. The mask bits are set to 1 for each position if the constraint applies.\n      lines.push(`\n      mask = ${this._constrainedIndexBitmask(constraint)}\n      value = derivedConstraints.${constraint}\n      `)\n\n      // If there's no constraint value, none of the handlers constrained by this constraint can match. Remove them from the candidates.\n      // If there is a constraint value, get the matching indexes bitmap from the store, and mask it down to only the indexes this constraint applies to, and then bitwise and with the candidates list to leave only matching candidates left.\n      const strategy = constrainer.strategies[constraint]\n      const matchMask = strategy.mustMatchWhenDerived ? 'matches' : '(matches | mask)'\n\n      lines.push(`\n      if (value === undefined) {\n        candidates &= mask\n      } else {\n        matches = this.constrainedHandlerStores.${constraint}.get(value) || 0\n        candidates &= ${matchMask}\n      }\n      if (candidates === 0) return null;\n      `)\n    }\n\n    // There are some constraints that can be derived and marked as \"must match\", where if they are derived, they only match routes that actually have a constraint on the value, like the SemVer version constraint.\n    // An example: a request comes in for version 1.x, and this node has a handler that matches the path, but there's no version constraint. For SemVer, the find-my-way semantics do not match this handler to that request.\n    // This function is used by Nodes with handlers to match when they don't have any constrained routes to exclude request that do have must match derived constraints present.\n    for (const constraint in constrainer.strategies) {\n      const strategy = constrainer.strategies[constraint]\n      if (strategy.mustMatchWhenDerived && !this.constraints.includes(constraint)) {\n        lines.push(`if (derivedConstraints.${constraint} !== undefined) return null`)\n      }\n    }\n\n    // Return the first handler who's bit is set in the candidates https://stackoverflow.com/questions/18134985/how-to-find-index-of-first-set-bit\n    lines.push('return this.handlers[Math.floor(Math.log2(candidates))]')\n\n    this._getHandlerMatchingConstraints = new Function('derivedConstraints', lines.join('\\n')) // eslint-disable-line\n  }\n}\n\nmodule.exports = HandlerStorage\n\n},{}],4:[function(require,module,exports){\n'use strict'\n\n/*\n  Char codes:\n    '!': 33 - !\n    '#': 35 - %23\n    '$': 36 - %24\n    '%': 37 - %25\n    '&': 38 - %26\n    ''': 39 - '\n    '(': 40 - (\n    ')': 41 - )\n    '*': 42 - *\n    '+': 43 - %2B\n    ',': 44 - %2C\n    '-': 45 - -\n    '.': 46 - .\n    '/': 47 - %2F\n    ':': 58 - %3A\n    ';': 59 - %3B\n    '=': 61 - %3D\n    '?': 63 - %3F\n    '@': 64 - %40\n    '_': 95 - _\n    '~': 126 - ~\n*/\n\nconst assert = require('./assert-mock.js')\nconst querystring = require('fast-querystring')\nconst isRegexSafe = require('safe-regex2')\nconst deepEqual = require('fast-deep-equal')\nconst { flattenNode, compressFlattenedNode, prettyPrintFlattenedNode, prettyPrintRoutesArray } = require('./lib/pretty-print')\nconst { StaticNode, NODE_TYPES } = require('./custom_node')\nconst Constrainer = require('./lib/constrainer')\nconst httpMethods = require('./lib/http-methods')\nconst { safeDecodeURI, safeDecodeURIComponent } = require('./lib/url-sanitizer')\n\nconst FULL_PATH_REGEXP = /^https?:\\/\\/.*?\\//\nconst OPTIONAL_PARAM_REGEXP = /(\\/:[^/()]*?)\\?(\\/?)/\n\nif (!isRegexSafe(FULL_PATH_REGEXP)) {\n  throw new Error('the FULL_PATH_REGEXP is not safe, update this module')\n}\n\nif (!isRegexSafe(OPTIONAL_PARAM_REGEXP)) {\n  throw new Error('the OPTIONAL_PARAM_REGEXP is not safe, update this module')\n}\n\nfunction Router (opts) {\n  if (!(this instanceof Router)) {\n    return new Router(opts)\n  }\n  opts = opts || {}\n\n  if (opts.defaultRoute) {\n    assert(typeof opts.defaultRoute === 'function', 'The default route must be a function')\n    this.defaultRoute = opts.defaultRoute\n  } else {\n    this.defaultRoute = null\n  }\n\n  if (opts.onBadUrl) {\n    assert(typeof opts.onBadUrl === 'function', 'The bad url handler must be a function')\n    this.onBadUrl = opts.onBadUrl\n  } else {\n    this.onBadUrl = null\n  }\n\n  if (opts.buildPrettyMeta) {\n    assert(typeof opts.buildPrettyMeta === 'function', 'buildPrettyMeta must be a function')\n    this.buildPrettyMeta = opts.buildPrettyMeta\n  } else {\n    this.buildPrettyMeta = defaultBuildPrettyMeta\n  }\n\n  if (opts.querystringParser) {\n    assert(typeof opts.querystringParser === 'function', 'querystringParser must be a function')\n    this.querystringParser = opts.querystringParser\n  } else {\n    this.querystringParser = (query) => query === '' ? {} : querystring.parse(query)\n  }\n\n  this.caseSensitive = opts.caseSensitive === undefined ? true : opts.caseSensitive\n  this.ignoreTrailingSlash = opts.ignoreTrailingSlash || false\n  this.ignoreDuplicateSlashes = opts.ignoreDuplicateSlashes || false\n  this.maxParamLength = opts.maxParamLength || 100\n  this.allowUnsafeRegex = opts.allowUnsafeRegex || false\n  this.routes = []\n  this.trees = {}\n  this.constrainer = new Constrainer(opts.constraints)\n\n  this._routesPatterns = {}\n}\n\nRouter.prototype.on = function on (method, path, opts, handler, store) {\n  if (typeof opts === 'function') {\n    if (handler !== undefined) {\n      store = handler\n    }\n    handler = opts\n    opts = {}\n  }\n  // path validation\n  assert(typeof path === 'string', 'Path should be a string')\n  assert(path.length > 0, 'The path could not be empty')\n  assert(path[0] === '/' || path[0] === '*', 'The first character of a path should be `/` or `*`')\n  // handler validation\n  assert(typeof handler === 'function', 'Handler should be a function')\n\n  // path ends with optional parameter\n  const optionalParamMatch = path.match(OPTIONAL_PARAM_REGEXP)\n  if (optionalParamMatch) {\n    assert(path.length === optionalParamMatch.index + optionalParamMatch[0].length, 'Optional Parameter needs to be the last parameter of the path')\n\n    const pathFull = path.replace(OPTIONAL_PARAM_REGEXP, '$1$2')\n    const pathOptional = path.replace(OPTIONAL_PARAM_REGEXP, '$2')\n\n    this.on(method, pathFull, opts, handler, store)\n    this.on(method, pathOptional, opts, handler, store)\n    return\n  }\n\n  const route = path\n\n  if (this.ignoreDuplicateSlashes) {\n    path = removeDuplicateSlashes(path)\n  }\n\n  if (this.ignoreTrailingSlash) {\n    path = trimLastSlash(path)\n  }\n\n  const methods = Array.isArray(method) ? method : [method]\n  for (const method of methods) {\n    this._on(method, path, opts, handler, store, route)\n    this.routes.push({ method, path, opts, handler, store })\n  }\n}\n\nRouter.prototype._on = function _on (method, path, opts, handler, store) {\n  assert(typeof method === 'string', 'Method should be a string')\n  assert(httpMethods.includes(method), `Method '${method}' is not an http method.`)\n\n  let constraints = {}\n  if (opts.constraints !== undefined) {\n    assert(typeof opts.constraints === 'object' && opts.constraints !== null, 'Constraints should be an object')\n    if (Object.keys(opts.constraints).length !== 0) {\n      constraints = opts.constraints\n    }\n  }\n\n  this.constrainer.validateConstraints(constraints)\n  // Let the constrainer know if any constraints are being used now\n  this.constrainer.noteUsage(constraints)\n\n  // Boot the tree for this method if it doesn't exist yet\n  if (this.trees[method] === undefined) {\n    this.trees[method] = new StaticNode('/')\n    this._routesPatterns[method] = []\n  }\n\n  if (path === '*' && this.trees[method].prefix.length !== 0) {\n    const currentRoot = this.trees[method]\n    this.trees[method] = new StaticNode('')\n    this.trees[method].staticChildren['/'] = currentRoot\n  }\n\n  let currentNode = this.trees[method]\n  let parentNodePathIndex = currentNode.prefix.length\n\n  const params = []\n  for (let i = 0; i <= path.length; i++) {\n    if (path.charCodeAt(i) === 58 && path.charCodeAt(i + 1) === 58) {\n      // It's a double colon\n      i++\n      continue\n    }\n\n    const isParametricNode = path.charCodeAt(i) === 58 && path.charCodeAt(i + 1) !== 58\n    const isWildcardNode = path.charCodeAt(i) === 42\n\n    if (isParametricNode || isWildcardNode || (i === path.length && i !== parentNodePathIndex)) {\n      let staticNodePath = path.slice(parentNodePathIndex, i)\n      if (!this.caseSensitive) {\n        staticNodePath = staticNodePath.toLowerCase()\n      }\n      staticNodePath = staticNodePath.split('::').join(':')\n      staticNodePath = staticNodePath.split('%').join('%25')\n      // add the static part of the route to the tree\n      currentNode = currentNode.createStaticChild(staticNodePath)\n    }\n\n    if (isParametricNode) {\n      let isRegexNode = false\n      const regexps = []\n\n      let lastParamStartIndex = i + 1\n      for (let j = lastParamStartIndex; ; j++) {\n        const charCode = path.charCodeAt(j)\n\n        const isRegexParam = charCode === 40\n        const isStaticPart = charCode === 45 || charCode === 46\n        const isEndOfNode = charCode === 47 || j === path.length\n\n        if (isRegexParam || isStaticPart || isEndOfNode) {\n          const paramName = path.slice(lastParamStartIndex, j)\n          params.push(paramName)\n\n          isRegexNode = isRegexNode || isRegexParam || isStaticPart\n\n          if (isRegexParam) {\n            const endOfRegexIndex = getClosingParenthensePosition(path, j)\n            const regexString = path.slice(j, endOfRegexIndex + 1)\n\n            if (!this.allowUnsafeRegex) {\n              assert(isRegexSafe(new RegExp(regexString)), `The regex '${regexString}' is not safe!`)\n            }\n\n            regexps.push(trimRegExpStartAndEnd(regexString))\n\n            j = endOfRegexIndex + 1\n          } else {\n            regexps.push('(.*?)')\n          }\n\n          const staticPartStartIndex = j\n          for (; j < path.length; j++) {\n            const charCode = path.charCodeAt(j)\n            if (charCode === 47) break\n            if (charCode === 58) {\n              const nextCharCode = path.charCodeAt(j + 1)\n              if (nextCharCode === 58) j++\n              else break\n            }\n          }\n\n          let staticPart = path.slice(staticPartStartIndex, j)\n          if (staticPart) {\n            staticPart = staticPart.split('::').join(':')\n            staticPart = staticPart.split('%').join('%25')\n            regexps.push(escapeRegExp(staticPart))\n          }\n\n          lastParamStartIndex = j + 1\n\n          if (isEndOfNode || path.charCodeAt(j) === 47 || j === path.length) {\n            const nodePattern = isRegexNode ? '()' + staticPart : staticPart\n\n            path = path.slice(0, i + 1) + nodePattern + path.slice(j)\n            i += nodePattern.length\n\n            const regex = isRegexNode ? new RegExp('^' + regexps.join('') + '$') : null\n            currentNode = currentNode.createParametricChild(regex, staticPart || null)\n            parentNodePathIndex = i + 1\n            break\n          }\n        }\n      }\n    } else if (isWildcardNode) {\n      // add the wildcard parameter\n      params.push('*')\n      currentNode = currentNode.createWildcardChild()\n      parentNodePathIndex = i + 1\n\n      if (i !== path.length - 1) {\n        throw new Error('Wildcard must be the last character in the route')\n      }\n    }\n  }\n\n  if (!this.caseSensitive) {\n    path = path.toLowerCase()\n  }\n\n  if (path === '*') {\n    path = '/*'\n  }\n\n  for (const existRoute of this._routesPatterns[method]) {\n    if (existRoute.path === path && deepEqual(existRoute.constraints, constraints)) {\n      throw new Error(`Method '${method}' already declared for route '${path}' with constraints '${JSON.stringify(constraints)}'`)\n    }\n  }\n  this._routesPatterns[method].push({ path, params, constraints })\n\n  currentNode.handlerStorage.addHandler(handler, params, store, this.constrainer, constraints)\n}\n\nRouter.prototype.hasConstraintStrategy = function (strategyName) {\n  return this.constrainer.hasConstraintStrategy(strategyName)\n}\n\nRouter.prototype.addConstraintStrategy = function (constraints) {\n  this.constrainer.addConstraintStrategy(constraints)\n  this._rebuild(this.routes)\n}\n\nRouter.prototype.reset = function reset () {\n  this.trees = {}\n  this.routes = []\n  this._routesPatterns = {}\n}\n\nRouter.prototype.off = function off (method, path, constraints) {\n  // path validation\n  assert(typeof path === 'string', 'Path should be a string')\n  assert(path.length > 0, 'The path could not be empty')\n  assert(path[0] === '/' || path[0] === '*', 'The first character of a path should be `/` or `*`')\n  // options validation\n  assert(\n    typeof constraints === 'undefined' ||\n    (typeof constraints === 'object' && !Array.isArray(constraints) && constraints !== null),\n    'Constraints should be an object or undefined.')\n\n  // path ends with optional parameter\n  const optionalParamMatch = path.match(OPTIONAL_PARAM_REGEXP)\n  if (optionalParamMatch) {\n    assert(path.length === optionalParamMatch.index + optionalParamMatch[0].length, 'Optional Parameter needs to be the last parameter of the path')\n\n    const pathFull = path.replace(OPTIONAL_PARAM_REGEXP, '$1$2')\n    const pathOptional = path.replace(OPTIONAL_PARAM_REGEXP, '$2')\n\n    this.off(method, pathFull, constraints)\n    this.off(method, pathOptional, constraints)\n    return\n  }\n\n  if (this.ignoreDuplicateSlashes) {\n    path = removeDuplicateSlashes(path)\n  }\n\n  if (this.ignoreTrailingSlash) {\n    path = trimLastSlash(path)\n  }\n\n  const methods = Array.isArray(method) ? method : [method]\n  for (const method of methods) {\n    this._off(method, path, constraints)\n  }\n}\n\nRouter.prototype._off = function _off (method, path, constraints) {\n  // method validation\n  assert(typeof method === 'string', 'Method should be a string')\n  assert(httpMethods.includes(method), `Method '${method}' is not an http method.`)\n\n  function matcherWithoutConstraints (route) {\n    return method !== route.method || path !== route.path\n  }\n\n  function matcherWithConstraints (route) {\n    return matcherWithoutConstraints(route) || !deepEqual(constraints, route.opts.constraints || {})\n  }\n\n  const predicate = constraints ? matcherWithConstraints : matcherWithoutConstraints\n\n  // Rebuild tree without the specific route\n  const newRoutes = this.routes.filter(predicate)\n  this._rebuild(newRoutes)\n}\n\nRouter.prototype.lookup = function lookup (req, res, ctx, done) {\n  if (typeof ctx === 'function') {\n    done = ctx\n    ctx = undefined\n  }\n\n  if (done === undefined) {\n    const constraints = this.constrainer.deriveConstraints(req, ctx)\n    const handle = this.find(req.method, req.url, constraints)\n    return this.callHandler(handle, req, res, ctx)\n  }\n\n  this.constrainer.deriveConstraints(req, ctx, (err, constraints) => {\n    if (err !== null) {\n      done(err)\n      return\n    }\n\n    try {\n      const handle = this.find(req.method, req.url, constraints)\n      const result = this.callHandler(handle, req, res, ctx)\n      done(null, result)\n    } catch (err) {\n      done(err)\n    }\n  })\n}\n\nRouter.prototype.callHandler = function callHandler (handle, req, res, ctx) {\n  if (handle === null) return this._defaultRoute(req, res, ctx)\n  return ctx === undefined\n    ? handle.handler(req, res, handle.params, handle.store, handle.searchParams)\n    : handle.handler.call(ctx, req, res, handle.params, handle.store, handle.searchParams)\n}\n\nRouter.prototype.find = function find (method, path, derivedConstraints) {\n  let currentNode = this.trees[method]\n  if (currentNode === undefined) return null\n\n  if (path.charCodeAt(0) !== 47) { // 47 is '/'\n    path = path.replace(FULL_PATH_REGEXP, '/')\n  }\n\n  // This must be run before sanitizeUrl as the resulting function\n  // .sliceParameter must be constructed with same URL string used\n  // throughout the rest of this function.\n  if (this.ignoreDuplicateSlashes) {\n    path = removeDuplicateSlashes(path)\n  }\n\n  let sanitizedUrl\n  let querystring\n  let shouldDecodeParam\n\n  try {\n    sanitizedUrl = safeDecodeURI(path)\n    path = sanitizedUrl.path\n    querystring = sanitizedUrl.querystring\n    shouldDecodeParam = sanitizedUrl.shouldDecodeParam\n  } catch (error) {\n    return this._onBadUrl(path)\n  }\n\n  if (this.ignoreTrailingSlash) {\n    path = trimLastSlash(path)\n  }\n\n  const originPath = path\n\n  if (this.caseSensitive === false) {\n    path = path.toLowerCase()\n  }\n\n  const maxParamLength = this.maxParamLength\n\n  let pathIndex = currentNode.prefix.length\n  const params = []\n  const pathLen = path.length\n\n  const brothersNodesStack = []\n\n  while (true) {\n    if (pathIndex === pathLen) {\n      const handle = currentNode.handlerStorage.getMatchingHandler(derivedConstraints)\n\n      if (handle !== null) {\n        return {\n          handler: handle.handler,\n          store: handle.store,\n          params: handle._createParamsObject(params),\n          searchParams: this.querystringParser(querystring)\n        }\n      }\n    }\n\n    let node = currentNode.getNextNode(path, pathIndex, brothersNodesStack, params.length)\n\n    if (node === null) {\n      if (brothersNodesStack.length === 0) {\n        return null\n      }\n\n      const brotherNodeState = brothersNodesStack.pop()\n      pathIndex = brotherNodeState.brotherPathIndex\n      params.splice(brotherNodeState.paramsCount)\n      node = brotherNodeState.brotherNode\n    }\n\n    currentNode = node\n\n    // static route\n    if (currentNode.kind === NODE_TYPES.STATIC) {\n      pathIndex += currentNode.prefix.length\n      continue\n    }\n\n    if (currentNode.kind === NODE_TYPES.WILDCARD) {\n      let param = originPath.slice(pathIndex)\n      if (shouldDecodeParam) {\n        param = safeDecodeURIComponent(param)\n      }\n\n      params.push(param)\n      pathIndex = pathLen\n      continue\n    }\n\n    if (currentNode.kind === NODE_TYPES.PARAMETRIC) {\n      let paramEndIndex = originPath.indexOf('/', pathIndex)\n      if (paramEndIndex === -1) {\n        paramEndIndex = pathLen\n      }\n\n      let param = originPath.slice(pathIndex, paramEndIndex)\n      if (shouldDecodeParam) {\n        param = safeDecodeURIComponent(param)\n      }\n\n      if (currentNode.isRegex) {\n        const matchedParameters = currentNode.regex.exec(param)\n        if (matchedParameters === null) continue\n\n        for (let i = 1; i < matchedParameters.length; i++) {\n          const matchedParam = matchedParameters[i]\n          if (matchedParam.length > maxParamLength) {\n            return null\n          }\n          params.push(matchedParam)\n        }\n      } else {\n        if (param.length > maxParamLength) {\n          return null\n        }\n        params.push(param)\n      }\n\n      pathIndex = paramEndIndex\n    }\n  }\n}\n\nRouter.prototype._rebuild = function (routes) {\n  this.reset()\n\n  for (const route of routes) {\n    const { method, path, opts, handler, store } = route\n    this._on(method, path, opts, handler, store)\n    this.routes.push({ method, path, opts, handler, store })\n  }\n}\n\nRouter.prototype._defaultRoute = function (req, res, ctx) {\n  if (this.defaultRoute !== null) {\n    return ctx === undefined\n      ? this.defaultRoute(req, res)\n      : this.defaultRoute.call(ctx, req, res)\n  } else {\n    res.statusCode = 404\n    res.end()\n  }\n}\n\nRouter.prototype._onBadUrl = function (path) {\n  if (this.onBadUrl === null) {\n    return null\n  }\n  const onBadUrl = this.onBadUrl\n  return {\n    handler: (req, res, ctx) => onBadUrl(path, req, res),\n    params: {},\n    store: null\n  }\n}\n\nRouter.prototype.prettyPrint = function (opts = {}) {\n  opts.commonPrefix = opts.commonPrefix === undefined ? true : opts.commonPrefix // default to original behaviour\n  if (!opts.commonPrefix) return prettyPrintRoutesArray.call(this, this.routes, opts)\n  const root = {\n    prefix: '/',\n    nodes: [],\n    children: {}\n  }\n\n  for (const method in this.trees) {\n    const node = this.trees[method]\n    if (node) {\n      flattenNode(root, node, method)\n    }\n  }\n\n  compressFlattenedNode(root)\n\n  return prettyPrintFlattenedNode.call(this, root, '', true, opts)\n}\n\nfor (var i in httpMethods) {\n  /* eslint no-prototype-builtins: \"off\" */\n  if (!httpMethods.hasOwnProperty(i)) continue\n  const m = httpMethods[i]\n  const methodName = m.toLowerCase()\n\n  if (Router.prototype[methodName]) throw new Error('Method already exists: ' + methodName)\n\n  Router.prototype[methodName] = function (path, handler, store) {\n    return this.on(m, path, handler, store)\n  }\n}\n\nRouter.prototype.all = function (path, handler, store) {\n  this.on(httpMethods, path, handler, store)\n}\n\nmodule.exports = Router\n\nfunction escapeRegExp (string) {\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')\n}\n\nfunction removeDuplicateSlashes (path) {\n  return path.replace(/\\/\\/+/g, '/')\n}\n\nfunction trimLastSlash (path) {\n  if (path.length > 1 && path.charCodeAt(path.length - 1) === 47) {\n    return path.slice(0, -1)\n  }\n  return path\n}\n\nfunction trimRegExpStartAndEnd (regexString) {\n  // removes chars that marks start \"^\" and end \"$\" of regexp\n  if (regexString.charCodeAt(1) === 94) {\n    regexString = regexString.slice(0, 1) + regexString.slice(2)\n  }\n\n  if (regexString.charCodeAt(regexString.length - 2) === 36) {\n    regexString = regexString.slice(0, regexString.length - 2) + regexString.slice(regexString.length - 1)\n  }\n\n  return regexString\n}\n\nfunction getClosingParenthensePosition (path, idx) {\n  // `path.indexOf()` will always return the first position of the closing parenthese,\n  // but it's inefficient for grouped or wrong regexp expressions.\n  // see issues #62 and #63 for more info\n\n  var parentheses = 1\n\n  while (idx < path.length) {\n    idx++\n\n    // ignore skipped chars\n    if (path[idx] === '\\\\') {\n      idx++\n      continue\n    }\n\n    if (path[idx] === ')') {\n      parentheses--\n    } else if (path[idx] === '(') {\n      parentheses++\n    }\n\n    if (!parentheses) return idx\n  }\n\n  throw new TypeError('Invalid regexp expression in \"' + path + '\"')\n}\n\nfunction defaultBuildPrettyMeta (route) {\n  // buildPrettyMeta function must return an object, which will be parsed into key/value pairs for display\n  if (!route) return {}\n  if (!route.store) return {}\n  return Object.assign({}, route.store)\n}\n\n},{\"./assert-mock.js\":1,\"./custom_node\":2,\"./lib/constrainer\":5,\"./lib/http-methods\":6,\"./lib/pretty-print\":7,\"./lib/url-sanitizer\":10,\"fast-deep-equal\":12,\"fast-querystring\":13,\"safe-regex2\":22}],5:[function(require,module,exports){\n'use strict'\n\nconst acceptVersionStrategy = require('./strategies/accept-version')\nconst acceptHostStrategy = require('./strategies/accept-host')\nconst assert = require('../assert-mock.js')\n\nclass Constrainer {\n  constructor (customStrategies) {\n    this.strategies = {\n      version: acceptVersionStrategy,\n      host: acceptHostStrategy\n    }\n\n    this.strategiesInUse = new Set()\n    this.asyncStrategiesInUse = new Set()\n\n    // validate and optimize prototypes of given custom strategies\n    if (customStrategies) {\n      for (const strategy of Object.values(customStrategies)) {\n        this.addConstraintStrategy(strategy)\n      }\n    }\n  }\n\n  isStrategyUsed (strategyName) {\n    return this.strategiesInUse.has(strategyName) ||\n      this.asyncStrategiesInUse.has(strategyName)\n  }\n\n  hasConstraintStrategy (strategyName) {\n    const customConstraintStrategy = this.strategies[strategyName]\n    if (customConstraintStrategy !== undefined) {\n      return customConstraintStrategy.isCustom ||\n        this.isStrategyUsed(strategyName)\n    }\n    return false\n  }\n\n  addConstraintStrategy (strategy) {\n    assert(typeof strategy.name === 'string' && strategy.name !== '', 'strategy.name is required.')\n    assert(strategy.storage && typeof strategy.storage === 'function', 'strategy.storage function is required.')\n    assert(strategy.deriveConstraint && typeof strategy.deriveConstraint === 'function', 'strategy.deriveConstraint function is required.')\n\n    if (this.strategies[strategy.name] && this.strategies[strategy.name].isCustom) {\n      throw new Error(`There already exists a custom constraint with the name ${strategy.name}.`)\n    }\n\n    if (this.isStrategyUsed(strategy.name)) {\n      throw new Error(`There already exists a route with ${strategy.name} constraint.`)\n    }\n\n    strategy.isCustom = true\n    strategy.isAsync = strategy.deriveConstraint.length === 3\n    this.strategies[strategy.name] = strategy\n\n    if (strategy.mustMatchWhenDerived) {\n      this.noteUsage({ [strategy.name]: strategy })\n    }\n  }\n\n  deriveConstraints (req, ctx, done) {\n    const constraints = this.deriveSyncConstraints(req, ctx)\n\n    if (done === undefined) {\n      return constraints\n    }\n\n    this.deriveAsyncConstraints(constraints, req, ctx, done)\n  }\n\n  deriveSyncConstraints (req, ctx) {\n    return undefined\n  }\n\n  // When new constraints start getting used, we need to rebuild the deriver to derive them. Do so if we see novel constraints used.\n  noteUsage (constraints) {\n    if (constraints) {\n      const beforeSize = this.strategiesInUse.size\n      for (const key in constraints) {\n        const strategy = this.strategies[key]\n        if (strategy.isAsync) {\n          this.asyncStrategiesInUse.add(key)\n        } else {\n          this.strategiesInUse.add(key)\n        }\n      }\n      if (beforeSize !== this.strategiesInUse.size) {\n        this._buildDeriveConstraints()\n      }\n    }\n  }\n\n  newStoreForConstraint (constraint) {\n    if (!this.strategies[constraint]) {\n      throw new Error(`No strategy registered for constraint key ${constraint}`)\n    }\n    return this.strategies[constraint].storage()\n  }\n\n  validateConstraints (constraints) {\n    for (const key in constraints) {\n      const value = constraints[key]\n      if (typeof value === 'undefined') {\n        throw new Error('Can\\'t pass an undefined constraint value, must pass null or no key at all')\n      }\n      const strategy = this.strategies[key]\n      if (!strategy) {\n        throw new Error(`No strategy registered for constraint key ${key}`)\n      }\n      if (strategy.validate) {\n        strategy.validate(value)\n      }\n    }\n  }\n\n  deriveAsyncConstraints (constraints, req, ctx, done) {\n    let asyncConstraintsCount = this.asyncStrategiesInUse.size\n\n    if (asyncConstraintsCount === 0) {\n      done(null, constraints)\n      return\n    }\n\n    constraints = constraints || {}\n    for (const key of this.asyncStrategiesInUse) {\n      const strategy = this.strategies[key]\n      strategy.deriveConstraint(req, ctx, (err, constraintValue) => {\n        if (err !== null) {\n          done(err)\n          return\n        }\n\n        constraints[key] = constraintValue\n\n        if (--asyncConstraintsCount === 0) {\n          done(null, constraints)\n        }\n      })\n    }\n  }\n\n  // Optimization: build a fast function for deriving the constraints for all the strategies at once. We inline the definitions of the version constraint and the host constraint for performance.\n  // If no constraining strategies are in use (no routes constrain on host, or version, or any custom strategies) then we don't need to derive constraints for each route match, so don't do anything special, and just return undefined\n  // This allows us to not allocate an object to hold constraint values if no constraints are defined.\n  _buildDeriveConstraints () {\n    if (this.strategiesInUse.size === 0) return\n\n    const lines = ['return {']\n\n    for (const key of this.strategiesInUse) {\n      const strategy = this.strategies[key]\n      // Optimization: inline the derivation for the common built in constraints\n      if (!strategy.isCustom) {\n        if (key === 'version') {\n          lines.push('   version: req.headers[\\'accept-version\\'],')\n        } else if (key === 'host') {\n          lines.push('   host: req.headers.host || req.headers[\\':authority\\'],')\n        } else {\n          throw new Error('unknown non-custom strategy for compiling constraint derivation function')\n        }\n      } else {\n        lines.push(`  ${strategy.name}: this.strategies.${key}.deriveConstraint(req, ctx),`)\n      }\n    }\n\n    lines.push('}')\n\n    this.deriveSyncConstraints = new Function('req', 'ctx', lines.join('\\n')).bind(this) // eslint-disable-line\n  }\n}\n\nmodule.exports = Constrainer\n\n},{\"../assert-mock.js\":1,\"./strategies/accept-host\":8,\"./strategies/accept-version\":9}],6:[function(require,module,exports){\n'use strict'\n\n// defined by Node.js http module, a snapshot from Node.js 18.12.0\nconst httpMethods = [\n  'ACL', 'BIND', 'CHECKOUT', 'CONNECT', 'COPY', 'DELETE',\n  'GET', 'HEAD', 'LINK', 'LOCK', 'M-SEARCH', 'MERGE',\n  'MKACTIVITY', 'MKCALENDAR', 'MKCOL', 'MOVE', 'NOTIFY', 'OPTIONS',\n  'PATCH', 'POST', 'PROPFIND', 'PROPPATCH', 'PURGE', 'PUT',\n  'REBIND', 'REPORT', 'SEARCH', 'SOURCE', 'SUBSCRIBE', 'TRACE',\n  'UNBIND', 'UNLINK', 'UNLOCK', 'UNSUBSCRIBE'\n]\n\nmodule.exports = httpMethods\n\n},{}],7:[function(require,module,exports){\n'use strict'\n\n/* eslint-disable no-multi-spaces */\nconst indent              = '    '\nconst branchIndent        = '│   '\nconst midBranchIndent     = '├── '\nconst endBranchIndent     = '└── '\nconst wildcardDelimiter   = '*'\nconst pathDelimiter       = '/'\nconst pathRegExp          = /(?=\\/)/\n/* eslint-enable */\n\nfunction parseFunctionName (fn) {\n  let fName = fn.name || ''\n\n  fName = fName.replace('bound', '').trim()\n  fName = (fName || 'anonymous') + '()'\n  return fName\n}\n\nfunction parseMeta (meta) {\n  if (Array.isArray(meta)) return meta.map(m => parseMeta(m))\n  if (typeof meta === 'symbol') return meta.toString()\n  if (typeof meta === 'function') return parseFunctionName(meta)\n  return meta\n}\n\nfunction buildMetaObject (route, metaArray) {\n  const out = {}\n  const cleanMeta = this.buildPrettyMeta(route)\n  if (!Array.isArray(metaArray)) metaArray = cleanMeta ? Reflect.ownKeys(cleanMeta) : []\n  metaArray.forEach(m => {\n    const metaKey = typeof m === 'symbol' ? m.toString() : m\n    if (cleanMeta && cleanMeta[m]) {\n      out[metaKey] = parseMeta(cleanMeta[m])\n    }\n  })\n  return out\n}\n\nfunction prettyPrintRoutesArray (routeArray, opts = {}) {\n  if (!this.buildPrettyMeta) throw new Error('buildPrettyMeta not defined')\n  opts.includeMeta = opts.includeMeta || null // array of meta objects to display\n  const mergedRouteArray = []\n\n  let tree = ''\n\n  routeArray.sort((a, b) => {\n    if (!a.path || !b.path) return 0\n    return a.path.localeCompare(b.path)\n  })\n\n  // merge alike paths\n  for (let i = 0; i < routeArray.length; i++) {\n    const route = routeArray[i]\n    const pathExists = mergedRouteArray.find(r => route.path === r.path)\n    if (pathExists) {\n      // path already declared, add new method and break out of loop\n      pathExists.handlers.push({\n        method: route.method,\n        opts: route.opts.constraints || undefined,\n        meta: opts.includeMeta ? buildMetaObject.call(this, route, opts.includeMeta) : null\n      })\n      continue\n    }\n\n    const routeHandler = {\n      method: route.method,\n      opts: route.opts.constraints || undefined,\n      meta: opts.includeMeta ? buildMetaObject.call(this, route, opts.includeMeta) : null\n    }\n    mergedRouteArray.push({\n      path: route.path,\n      methods: [route.method],\n      opts: [route.opts],\n      handlers: [routeHandler]\n    })\n  }\n\n  // insert root level path if none defined\n  if (!mergedRouteArray.filter(r => r.path === pathDelimiter).length) {\n    const rootPath = {\n      path: pathDelimiter,\n      truncatedPath: '',\n      methods: [],\n      opts: [],\n      handlers: [{}]\n    }\n\n    // if wildcard route exists, insert root level after wildcard\n    if (mergedRouteArray.filter(r => r.path === wildcardDelimiter).length) {\n      mergedRouteArray.splice(1, 0, rootPath)\n    } else {\n      mergedRouteArray.unshift(rootPath)\n    }\n  }\n\n  // build tree\n  const routeTree = buildRouteTree(mergedRouteArray)\n\n  // draw tree\n  routeTree.forEach((rootBranch, idx) => {\n    tree += drawBranch(rootBranch, null, idx === routeTree.length - 1, false, true)\n    tree += '\\n' // newline characters inserted at beginning of drawing function to allow for nested paths\n  })\n\n  return tree\n}\n\nfunction buildRouteTree (mergedRouteArray) {\n  const result = []\n  const temp = { result }\n  mergedRouteArray.forEach((route, idx) => {\n    let splitPath = route.path.split(pathRegExp)\n\n    // add preceding slash for proper nesting\n    if (splitPath[0] !== pathDelimiter) {\n      // handle wildcard route\n      if (splitPath[0] !== wildcardDelimiter) splitPath = [pathDelimiter, splitPath[0].slice(1), ...splitPath.slice(1)]\n    }\n\n    // build tree\n    splitPath.reduce((acc, path, pidx) => {\n      if (!acc[path]) {\n        acc[path] = { result: [] }\n        const pathSeg = { path, children: acc[path].result }\n\n        if (pidx === splitPath.length - 1) pathSeg.handlers = route.handlers\n        acc.result.push(pathSeg)\n      }\n      return acc[path]\n    }, temp)\n  })\n\n  // unfold root object from array\n  return result\n}\n\nfunction drawBranch (pathSeg, prefix, endBranch, noPrefix, rootBranch) {\n  let branch = ''\n\n  if (!noPrefix && !rootBranch) branch += '\\n'\n  if (!noPrefix) branch += `${prefix || ''}${endBranch ? endBranchIndent : midBranchIndent}`\n  branch += `${pathSeg.path}`\n\n  if (pathSeg.handlers) {\n    const flatHandlers = pathSeg.handlers.reduce((acc, curr) => {\n      const match = acc.findIndex(h => JSON.stringify(h.opts) === JSON.stringify(curr.opts))\n      if (match !== -1) {\n        acc[match].method = [acc[match].method, curr.method].join(', ')\n      } else {\n        acc.push(curr)\n      }\n      return acc\n    }, [])\n\n    flatHandlers.forEach((handler, idx) => {\n      if (idx > 0) branch += `${noPrefix ? '' : prefix || ''}${endBranch ? indent : branchIndent}${pathSeg.path}`\n      branch += ` (${handler.method || '-'})`\n      if (handler.opts && JSON.stringify(handler.opts) !== '{}') branch += ` ${JSON.stringify(handler.opts)}`\n      if (handler.meta) {\n        Reflect.ownKeys(handler.meta).forEach((m, hidx) => {\n          branch += `\\n${noPrefix ? '' : prefix || ''}${endBranch ? indent : branchIndent}`\n          branch += `• (${m}) ${JSON.stringify(handler.meta[m])}`\n        })\n      }\n      if (flatHandlers.length > 1 && idx !== flatHandlers.length - 1) branch += '\\n'\n    })\n  } else {\n    if (pathSeg.children.length > 1) branch += ' (-)'\n  }\n\n  if (!noPrefix) prefix = `${prefix || ''}${endBranch ? indent : branchIndent}`\n\n  pathSeg.children.forEach((child, idx) => {\n    const endBranch = idx === pathSeg.children.length - 1\n    const skipPrefix = (!pathSeg.handlers && pathSeg.children.length === 1)\n    branch += drawBranch(child, prefix, endBranch, skipPrefix)\n  })\n\n  return branch\n}\n\nfunction prettyPrintFlattenedNode (flattenedNode, prefix, tail, opts) {\n  if (!this.buildPrettyMeta) throw new Error('buildPrettyMeta not defined')\n  opts.includeMeta = opts.includeMeta || null // array of meta items to display\n  let paramName = ''\n  const printHandlers = []\n\n  for (const { node, method } of flattenedNode.nodes) {\n    for (const handler of node.handlerStorage.handlers) {\n      printHandlers.push({ method, ...handler })\n    }\n  }\n\n  if (printHandlers.length) {\n    printHandlers.forEach((handler, index) => {\n      let suffix = `(${handler.method || '-'})`\n      if (Object.keys(handler.constraints).length > 0) {\n        suffix += ' ' + JSON.stringify(handler.constraints)\n      }\n\n      let name = ''\n      // find locations of parameters in prefix\n      const paramIndices = flattenedNode.prefix.split('').map((ch, idx) => ch === ':' ? idx : null).filter(idx => idx !== null)\n      if (paramIndices.length) {\n        let prevLoc = 0\n        paramIndices.forEach((loc, idx) => {\n          // find parameter in prefix\n          name += flattenedNode.prefix.slice(prevLoc, loc + 1)\n          // insert parameters\n          name += handler.params[handler.params.length - paramIndices.length + idx]\n          if (idx === paramIndices.length - 1) name += flattenedNode.prefix.slice(loc + 1)\n          prevLoc = loc + 1\n        })\n      } else {\n        // there are no parameters, return full object\n        name = flattenedNode.prefix\n      }\n\n      if (index === 0) {\n        paramName += `${name} ${suffix}`\n      } else {\n        paramName += `\\n${prefix}${tail ? indent : branchIndent}${name} ${suffix}`\n      }\n      if (opts.includeMeta) {\n        const meta = buildMetaObject.call(this, handler, opts.includeMeta)\n        Object.keys(meta).forEach((m, hidx) => {\n          paramName += `\\n${prefix || ''}${tail ? indent : branchIndent}`\n          paramName += `• (${m}) ${JSON.stringify(meta[m])}`\n        })\n      }\n    })\n  } else {\n    paramName = flattenedNode.prefix\n  }\n\n  let tree = `${prefix}${tail ? endBranchIndent : midBranchIndent}${paramName}\\n`\n\n  prefix = `${prefix}${tail ? indent : branchIndent}`\n  const labels = Object.keys(flattenedNode.children)\n  for (let i = 0; i < labels.length; i++) {\n    const child = flattenedNode.children[labels[i]]\n    tree += prettyPrintFlattenedNode.call(this, child, prefix, i === (labels.length - 1), opts)\n  }\n  return tree\n}\n\nfunction flattenNode (flattened, node, method) {\n  if (node.handlerStorage.handlers.length !== 0) {\n    flattened.nodes.push({ method, node })\n  }\n\n  if (node.parametricChildren && node.parametricChildren[0]) {\n    if (!flattened.children[':']) {\n      flattened.children[':'] = {\n        prefix: ':',\n        nodes: [],\n        children: {}\n      }\n    }\n    flattenNode(flattened.children[':'], node.parametricChildren[0], method)\n  }\n\n  if (node.wildcardChild) {\n    if (!flattened.children['*']) {\n      flattened.children['*'] = {\n        prefix: '*',\n        nodes: [],\n        children: {}\n      }\n    }\n    flattenNode(flattened.children['*'], node.wildcardChild, method)\n  }\n\n  if (node.staticChildren) {\n    for (const child of Object.values(node.staticChildren)) {\n      // split on the slash separator but use a regex to lookahead and not actually match it, preserving it in the returned string segments\n      const childPrefixSegments = child.prefix.split(pathRegExp)\n      let cursor = flattened\n      let parent\n      for (const segment of childPrefixSegments) {\n        parent = cursor\n        cursor = cursor.children[segment]\n        if (!cursor) {\n          cursor = {\n            prefix: segment,\n            nodes: [],\n            children: {}\n          }\n          parent.children[segment] = cursor\n        }\n      }\n      flattenNode(cursor, child, method)\n    }\n  }\n}\n\nfunction compressFlattenedNode (flattenedNode) {\n  const childKeys = Object.keys(flattenedNode.children)\n  if (flattenedNode.nodes.length === 0 && childKeys.length === 1) {\n    const child = flattenedNode.children[childKeys[0]]\n    if (child.nodes.length <= 1) {\n      compressFlattenedNode(child)\n      flattenedNode.nodes = child.nodes\n      flattenedNode.prefix += child.prefix\n      flattenedNode.children = child.children\n      return flattenedNode\n    }\n  }\n\n  for (const key of Object.keys(flattenedNode.children)) {\n    compressFlattenedNode(flattenedNode.children[key])\n  }\n\n  return flattenedNode\n}\n\nmodule.exports = { flattenNode, compressFlattenedNode, prettyPrintFlattenedNode, prettyPrintRoutesArray }\n\n},{}],8:[function(require,module,exports){\n'use strict'\nconst assert = require('../../assert-mock.js')\n\nfunction HostStorage () {\n  const hosts = {}\n  const regexHosts = []\n  return {\n    get: (host) => {\n      const exact = hosts[host]\n      if (exact) {\n        return exact\n      }\n      for (const regex of regexHosts) {\n        if (regex.host.test(host)) {\n          return regex.value\n        }\n      }\n    },\n    set: (host, value) => {\n      if (host instanceof RegExp) {\n        regexHosts.push({ host, value })\n      } else {\n        hosts[host] = value\n      }\n    }\n  }\n}\n\nmodule.exports = {\n  name: 'host',\n  mustMatchWhenDerived: false,\n  storage: HostStorage,\n  validate (value) {\n    assert(typeof value === 'string' || Object.prototype.toString.call(value) === '[object RegExp]', 'Host should be a string or a RegExp')\n  }\n}\n\n},{\"../../assert-mock.js\":1}],9:[function(require,module,exports){\n'use strict'\n\nconst assert = require('../../assert-mock.js')\n\nfunction SemVerStore () {\n  if (!(this instanceof SemVerStore)) {\n    return new SemVerStore()\n  }\n\n  this.store = {}\n\n  this.maxMajor = 0\n  this.maxMinors = {}\n  this.maxPatches = {}\n}\n\nSemVerStore.prototype.set = function (version, store) {\n  if (typeof version !== 'string') {\n    throw new TypeError('Version should be a string')\n  }\n  let [major, minor, patch] = version.split('.')\n\n  major = Number(major) || 0\n  minor = Number(minor) || 0\n  patch = Number(patch) || 0\n\n  if (major >= this.maxMajor) {\n    this.maxMajor = major\n    this.store.x = store\n    this.store['*'] = store\n    this.store['x.x'] = store\n    this.store['x.x.x'] = store\n  }\n\n  if (minor >= (this.maxMinors[major] || 0)) {\n    this.maxMinors[major] = minor\n    this.store[`${major}.x`] = store\n    this.store[`${major}.x.x`] = store\n  }\n\n  if (patch >= (this.store[`${major}.${minor}`] || 0)) {\n    this.maxPatches[`${major}.${minor}`] = patch\n    this.store[`${major}.${minor}.x`] = store\n  }\n\n  this.store[`${major}.${minor}.${patch}`] = store\n  return this\n}\n\nSemVerStore.prototype.get = function (version) {\n  return this.store[version]\n}\n\nmodule.exports = {\n  name: 'version',\n  mustMatchWhenDerived: true,\n  storage: SemVerStore,\n  validate (value) {\n    assert(typeof value === 'string', 'Version should be a string')\n  }\n}\n\n},{\"../../assert-mock.js\":1}],10:[function(require,module,exports){\n'use strict'\n\n// It must spot all the chars where decodeURIComponent(x) !== decodeURI(x)\n// The chars are: # $ & + , / : ; = ? @\nfunction decodeComponentChar (highCharCode, lowCharCode) {\n  if (highCharCode === 50) {\n    if (lowCharCode === 53) return '%'\n\n    if (lowCharCode === 51) return '#'\n    if (lowCharCode === 52) return '$'\n    if (lowCharCode === 54) return '&'\n    if (lowCharCode === 66) return '+'\n    if (lowCharCode === 98) return '+'\n    if (lowCharCode === 67) return ','\n    if (lowCharCode === 99) return ','\n    if (lowCharCode === 70) return '/'\n    if (lowCharCode === 102) return '/'\n    return null\n  }\n  if (highCharCode === 51) {\n    if (lowCharCode === 65) return ':'\n    if (lowCharCode === 97) return ':'\n    if (lowCharCode === 66) return ';'\n    if (lowCharCode === 98) return ';'\n    if (lowCharCode === 68) return '='\n    if (lowCharCode === 100) return '='\n    if (lowCharCode === 70) return '?'\n    if (lowCharCode === 102) return '?'\n    return null\n  }\n  if (highCharCode === 52 && lowCharCode === 48) {\n    return '@'\n  }\n  return null\n}\n\nfunction safeDecodeURI (path) {\n  let shouldDecode = false\n  let shouldDecodeParam = false\n\n  let querystring = ''\n\n  for (let i = 1; i < path.length; i++) {\n    const charCode = path.charCodeAt(i)\n\n    if (charCode === 37) {\n      const highCharCode = path.charCodeAt(i + 1)\n      const lowCharCode = path.charCodeAt(i + 2)\n\n      if (decodeComponentChar(highCharCode, lowCharCode) === null) {\n        shouldDecode = true\n      } else {\n        shouldDecodeParam = true\n        // %25 - encoded % char. We need to encode one more time to prevent double decoding\n        if (highCharCode === 50 && lowCharCode === 53) {\n          shouldDecode = true\n          path = path.slice(0, i + 1) + '25' + path.slice(i + 1)\n          i += 2\n        }\n        i += 2\n      }\n    // Some systems do not follow RFC and separate the path and query\n    // string with a `;` character (code 59), e.g. `/foo;jsessionid=123456`.\n    // Thus, we need to split on `;` as well as `?` and `#`.\n    } else if (charCode === 63 || charCode === 59 || charCode === 35) {\n      querystring = path.slice(i + 1)\n      path = path.slice(0, i)\n      break\n    }\n  }\n  const decodedPath = shouldDecode ? decodeURI(path) : path\n  return { path: decodedPath, querystring, shouldDecodeParam }\n}\n\nfunction safeDecodeURIComponent (uriComponent) {\n  const startIndex = uriComponent.indexOf('%')\n  if (startIndex === -1) return uriComponent\n\n  let decoded = ''\n  let lastIndex = startIndex\n\n  for (let i = startIndex; i < uriComponent.length; i++) {\n    if (uriComponent.charCodeAt(i) === 37) {\n      const highCharCode = uriComponent.charCodeAt(i + 1)\n      const lowCharCode = uriComponent.charCodeAt(i + 2)\n\n      const decodedChar = decodeComponentChar(highCharCode, lowCharCode)\n      decoded += uriComponent.slice(lastIndex, i) + decodedChar\n\n      lastIndex = i + 3\n    }\n  }\n  return uriComponent.slice(0, startIndex) + decoded + uriComponent.slice(lastIndex)\n}\n\nmodule.exports = { safeDecodeURI, safeDecodeURIComponent }\n\n},{}],11:[function(require,module,exports){\n'use strict'\n\nvar UTF8_ACCEPT = 12\nvar UTF8_REJECT = 0\nvar UTF8_DATA = [\n  // The first part of the table maps bytes to character to a transition.\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n  4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n  5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n  6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 7, 7,\n  10, 9, 9, 9, 11, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n\n  // The second part of the table maps a state to a new state when adding a\n  // transition.\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  12, 0, 0, 0, 0, 24, 36, 48, 60, 72, 84, 96,\n  0, 12, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 24, 24, 24, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 24, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 48, 48, 48, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 48, 48, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\n  // The third part maps the current transition to a mask that needs to apply\n  // to the byte.\n  0x7F, 0x3F, 0x3F, 0x3F, 0x00, 0x1F, 0x0F, 0x0F, 0x0F, 0x07, 0x07, 0x07\n]\n\nfunction decodeURIComponent (uri) {\n  var percentPosition = uri.indexOf('%')\n  if (percentPosition === -1) return uri\n\n  var length = uri.length\n  var decoded = ''\n  var last = 0\n  var codepoint = 0\n  var startOfOctets = percentPosition\n  var state = UTF8_ACCEPT\n\n  while (percentPosition > -1 && percentPosition < length) {\n    var high = hexCodeToInt(uri[percentPosition + 1], 4)\n    var low = hexCodeToInt(uri[percentPosition + 2], 0)\n    var byte = high | low\n    var type = UTF8_DATA[byte]\n    state = UTF8_DATA[256 + state + type]\n    codepoint = (codepoint << 6) | (byte & UTF8_DATA[364 + type])\n\n    if (state === UTF8_ACCEPT) {\n      decoded += uri.slice(last, startOfOctets)\n\n      decoded += (codepoint <= 0xFFFF)\n        ? String.fromCharCode(codepoint)\n        : String.fromCharCode(\n          (0xD7C0 + (codepoint >> 10)),\n          (0xDC00 + (codepoint & 0x3FF))\n        )\n\n      codepoint = 0\n      last = percentPosition + 3\n      percentPosition = startOfOctets = uri.indexOf('%', last)\n    } else if (state === UTF8_REJECT) {\n      return null\n    } else {\n      percentPosition += 3\n      if (percentPosition < length && uri.charCodeAt(percentPosition) === 37) continue\n      return null\n    }\n  }\n\n  return decoded + uri.slice(last)\n}\n\nvar HEX = {\n  '0': 0,\n  '1': 1,\n  '2': 2,\n  '3': 3,\n  '4': 4,\n  '5': 5,\n  '6': 6,\n  '7': 7,\n  '8': 8,\n  '9': 9,\n  'a': 10,\n  'A': 10,\n  'b': 11,\n  'B': 11,\n  'c': 12,\n  'C': 12,\n  'd': 13,\n  'D': 13,\n  'e': 14,\n  'E': 14,\n  'f': 15,\n  'F': 15\n}\n\nfunction hexCodeToInt (c, shift) {\n  var i = HEX[c]\n  return i === undefined ? 255 : i << shift\n}\n\nmodule.exports = decodeURIComponent\n\n},{}],12:[function(require,module,exports){\n'use strict';\n\n// do not edit .js files directly - edit src/index.jst\n\n\n\nmodule.exports = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n\n    var length, i, keys;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;)\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  // true if both NaN, false otherwise\n  return a!==a && b!==b;\n};\n\n},{}],13:[function(require,module,exports){\n\"use strict\";\n\nconst parse = require(\"./parse\");\nconst stringify = require(\"./stringify\");\n\nconst fastQuerystring = {\n  parse,\n  stringify,\n};\n\n/**\n * Enable TS and JS support\n *\n * - `const qs = require('fast-querystring')`\n * - `import qs from 'fast-querystring'`\n */\nmodule.exports = fastQuerystring;\nmodule.exports.default = fastQuerystring;\nmodule.exports.parse = parse;\nmodule.exports.stringify = stringify;\n\n},{\"./parse\":15,\"./stringify\":16}],14:[function(require,module,exports){\n// This file is taken from Node.js project.\n// Full implementation can be found from https://github.com/nodejs/node/blob/main/lib/internal/querystring.js\n\nconst hexTable = Array.from(\n  { length: 256 },\n  (_, i) => \"%\" + ((i < 16 ? \"0\" : \"\") + i.toString(16)).toUpperCase(),\n);\n\n// These characters do not need escaping when generating query strings:\n// ! - . _ ~\n// ' ( ) *\n// digits\n// alpha (uppercase)\n// alpha (lowercase)\n// rome-ignore format: the array should not be formatted\nconst noEscape = new Int8Array([\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0 - 15\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31\n  0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, // 32 - 47\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, // 48 - 63\n  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, // 80 - 95\n  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, // 112 - 127\n]);\n\n/**\n * @param {string} str\n * @returns {string}\n */\nfunction encodeString(str) {\n  const len = str.length;\n  if (len === 0) return \"\";\n\n  let out = \"\";\n  let lastPos = 0;\n  let i = 0;\n\n  outer: for (; i < len; i++) {\n    let c = str.charCodeAt(i);\n\n    // ASCII\n    while (c < 0x80) {\n      if (noEscape[c] !== 1) {\n        if (lastPos < i) out += str.slice(lastPos, i);\n        lastPos = i + 1;\n        out += hexTable[c];\n      }\n\n      if (++i === len) break outer;\n\n      c = str.charCodeAt(i);\n    }\n\n    if (lastPos < i) out += str.slice(lastPos, i);\n\n    // Multi-byte characters ...\n    if (c < 0x800) {\n      lastPos = i + 1;\n      out += hexTable[0xc0 | (c >> 6)] + hexTable[0x80 | (c & 0x3f)];\n      continue;\n    }\n    if (c < 0xd800 || c >= 0xe000) {\n      lastPos = i + 1;\n      out +=\n        hexTable[0xe0 | (c >> 12)] +\n        hexTable[0x80 | ((c >> 6) & 0x3f)] +\n        hexTable[0x80 | (c & 0x3f)];\n      continue;\n    }\n    // Surrogate pair\n    ++i;\n\n    // This branch should never happen because all URLSearchParams entries\n    // should already be converted to USVString. But, included for\n    // completion's sake anyway.\n    if (i >= len) {\n      throw new Error(\"URI malformed\");\n    }\n\n    const c2 = str.charCodeAt(i) & 0x3ff;\n\n    lastPos = i + 1;\n    c = 0x10000 + (((c & 0x3ff) << 10) | c2);\n    out +=\n      hexTable[0xf0 | (c >> 18)] +\n      hexTable[0x80 | ((c >> 12) & 0x3f)] +\n      hexTable[0x80 | ((c >> 6) & 0x3f)] +\n      hexTable[0x80 | (c & 0x3f)];\n  }\n  if (lastPos === 0) return str;\n  if (lastPos < len) return out + str.slice(lastPos);\n  return out;\n}\n\nmodule.exports = { encodeString };\n\n},{}],15:[function(require,module,exports){\n\"use strict\";\n\nconst fastDecode = require(\"fast-decode-uri-component\");\n\nconst plusRegex = /\\+/g;\nconst Empty = function () {};\nEmpty.prototype = Object.create(null);\n\n/**\n * @callback parse\n * @param {string} input\n */\nfunction parse(input) {\n  // Optimization: Use new Empty() instead of Object.create(null) for performance\n  // v8 has a better optimization for initializing functions compared to Object\n  const result = new Empty();\n\n  if (typeof input !== \"string\") {\n    return result;\n  }\n\n  let inputLength = input.length;\n  let key = \"\";\n  let value = \"\";\n  let startingIndex = -1;\n  let equalityIndex = -1;\n  let shouldDecodeKey = false;\n  let shouldDecodeValue = false;\n  let keyHasPlus = false;\n  let valueHasPlus = false;\n  let hasBothKeyValuePair = false;\n  let c = 0;\n\n  // Have a boundary of input.length + 1 to access last pair inside the loop.\n  for (let i = 0; i < inputLength + 1; i++) {\n    c = i !== inputLength ? input.charCodeAt(i) : 38;\n\n    // Handle '&' and end of line to pass the current values to result\n    if (c === 38) {\n      hasBothKeyValuePair = equalityIndex > startingIndex;\n\n      // Optimization: Reuse equality index to store the end of key\n      if (!hasBothKeyValuePair) {\n        equalityIndex = i;\n      }\n\n      key = input.slice(startingIndex + 1, equalityIndex);\n\n      // Add key/value pair only if the range size is greater than 1; a.k.a. contains at least \"=\"\n      if (hasBothKeyValuePair || key.length > 0) {\n        // Optimization: Replace '+' with space\n        if (keyHasPlus) {\n          key = key.replace(plusRegex, \" \");\n        }\n\n        // Optimization: Do not decode if it's not necessary.\n        if (shouldDecodeKey) {\n          key = fastDecode(key) || key;\n        }\n\n        if (hasBothKeyValuePair) {\n          value = input.slice(equalityIndex + 1, i);\n\n          if (valueHasPlus) {\n            value = value.replace(plusRegex, \" \");\n          }\n\n          if (shouldDecodeValue) {\n            value = fastDecode(value) || value;\n          }\n        }\n        const currentValue = result[key];\n\n        if (currentValue === undefined) {\n          result[key] = value;\n        } else {\n          // Optimization: value.pop is faster than Array.isArray(value)\n          if (currentValue.pop) {\n            currentValue.push(value);\n          } else {\n            result[key] = [currentValue, value];\n          }\n        }\n      }\n\n      // Reset reading key value pairs\n      value = \"\";\n      startingIndex = i;\n      equalityIndex = i;\n      shouldDecodeKey = false;\n      shouldDecodeValue = false;\n      keyHasPlus = false;\n      valueHasPlus = false;\n    }\n    // Check '='\n    else if (c === 61) {\n      if (equalityIndex <= startingIndex) {\n        equalityIndex = i;\n      }\n      // If '=' character occurs again, we should decode the input.\n      else {\n        shouldDecodeValue = true;\n      }\n    }\n    // Check '+', and remember to replace it with empty space.\n    else if (c === 43) {\n      if (equalityIndex > startingIndex) {\n        valueHasPlus = true;\n      } else {\n        keyHasPlus = true;\n      }\n    }\n    // Check '%' character for encoding\n    else if (c === 37) {\n      if (equalityIndex > startingIndex) {\n        shouldDecodeValue = true;\n      } else {\n        shouldDecodeKey = true;\n      }\n    }\n  }\n\n  return result;\n}\n\nmodule.exports = parse;\n\n},{\"fast-decode-uri-component\":11}],16:[function(require,module,exports){\n\"use strict\";\n\nconst { encodeString } = require(\"./internals/querystring\");\n\nfunction getAsPrimitive(value) {\n  const type = typeof value;\n\n  if (type === \"string\") {\n    // Length check is handled inside encodeString function\n    return encodeString(value);\n  } else if (type === \"bigint\") {\n    return value.toString();\n  } else if (type === \"boolean\") {\n    return value ? \"true\" : \"false\";\n  } else if (type === \"number\" && Number.isFinite(value)) {\n    return value < 1e21 ? \"\" + value : encodeString(\"\" + value);\n  }\n\n  return \"\";\n}\n\n/**\n * @param {Record<string, string | number | boolean\n * | ReadonlyArray<string | number | boolean> | null>} input\n * @returns {string}\n */\nfunction stringify(input) {\n  let result = \"\";\n\n  if (input === null || typeof input !== \"object\") {\n    return result;\n  }\n\n  const separator = \"&\";\n  const keys = Object.keys(input);\n  const keyLength = keys.length;\n  let valueLength = 0;\n\n  for (let i = 0; i < keyLength; i++) {\n    const key = keys[i];\n    const value = input[key];\n    const encodedKey = encodeString(key) + \"=\";\n\n    if (i) {\n      result += separator;\n    }\n\n    if (Array.isArray(value)) {\n      valueLength = value.length;\n      for (let j = 0; j < valueLength; j++) {\n        if (j) {\n          result += separator;\n        }\n\n        // Optimization: Dividing into multiple lines improves the performance.\n        // Since v8 does not need to care about the '+' character if it was one-liner.\n        result += encodedKey;\n        result += getAsPrimitive(value[j]);\n      }\n    } else {\n      result += encodedKey;\n      result += getAsPrimitive(value);\n    }\n  }\n\n  return result;\n}\n\nmodule.exports = stringify;\n\n},{\"./internals/querystring\":14}],17:[function(require,module,exports){\nconst util      = require('./util');\nconst types     = require('./types');\nconst sets      = require('./sets');\nconst positions = require('./positions');\n\n\nmodule.exports = (regexpStr) => {\n  var i = 0, l, c,\n    start = { type: types.ROOT, stack: []},\n\n    // Keep track of last clause/group and stack.\n    lastGroup = start,\n    last = start.stack,\n    groupStack = [];\n\n\n  var repeatErr = (i) => {\n    util.error(regexpStr, `Nothing to repeat at column ${i - 1}`);\n  };\n\n  // Decode a few escaped characters.\n  var str = util.strToChars(regexpStr);\n  l = str.length;\n\n  // Iterate through each character in string.\n  while (i < l) {\n    c = str[i++];\n\n    switch (c) {\n      // Handle escaped characters, inclues a few sets.\n      case '\\\\':\n        c = str[i++];\n\n        switch (c) {\n          case 'b':\n            last.push(positions.wordBoundary());\n            break;\n\n          case 'B':\n            last.push(positions.nonWordBoundary());\n            break;\n\n          case 'w':\n            last.push(sets.words());\n            break;\n\n          case 'W':\n            last.push(sets.notWords());\n            break;\n\n          case 'd':\n            last.push(sets.ints());\n            break;\n\n          case 'D':\n            last.push(sets.notInts());\n            break;\n\n          case 's':\n            last.push(sets.whitespace());\n            break;\n\n          case 'S':\n            last.push(sets.notWhitespace());\n            break;\n\n          default:\n            // Check if c is integer.\n            // In which case it's a reference.\n            if (/\\d/.test(c)) {\n              last.push({ type: types.REFERENCE, value: parseInt(c, 10) });\n\n            // Escaped character.\n            } else {\n              last.push({ type: types.CHAR, value: c.charCodeAt(0) });\n            }\n        }\n\n        break;\n\n\n      // Positionals.\n      case '^':\n        last.push(positions.begin());\n        break;\n\n      case '$':\n        last.push(positions.end());\n        break;\n\n\n      // Handle custom sets.\n      case '[':\n        // Check if this class is 'anti' i.e. [^abc].\n        var not;\n        if (str[i] === '^') {\n          not = true;\n          i++;\n        } else {\n          not = false;\n        }\n\n        // Get all the characters in class.\n        var classTokens = util.tokenizeClass(str.slice(i), regexpStr);\n\n        // Increase index by length of class.\n        i += classTokens[1];\n        last.push({\n          type: types.SET,\n          set: classTokens[0],\n          not,\n        });\n\n        break;\n\n\n      // Class of any character except \\n.\n      case '.':\n        last.push(sets.anyChar());\n        break;\n\n\n      // Push group onto stack.\n      case '(':\n        // Create group.\n        var group = {\n          type: types.GROUP,\n          stack: [],\n          remember: true,\n        };\n\n        c = str[i];\n\n        // If if this is a special kind of group.\n        if (c === '?') {\n          c = str[i + 1];\n          i += 2;\n\n          // Match if followed by.\n          if (c === '=') {\n            group.followedBy = true;\n\n          // Match if not followed by.\n          } else if (c === '!') {\n            group.notFollowedBy = true;\n\n          } else if (c !== ':') {\n            util.error(regexpStr,\n              `Invalid group, character '${c}'` +\n              ` after '?' at column ${i - 1}`);\n          }\n\n          group.remember = false;\n        }\n\n        // Insert subgroup into current group stack.\n        last.push(group);\n\n        // Remember the current group for when the group closes.\n        groupStack.push(lastGroup);\n\n        // Make this new group the current group.\n        lastGroup = group;\n        last = group.stack;\n        break;\n\n\n      // Pop group out of stack.\n      case ')':\n        if (groupStack.length === 0) {\n          util.error(regexpStr, `Unmatched ) at column ${i - 1}`);\n        }\n        lastGroup = groupStack.pop();\n\n        // Check if this group has a PIPE.\n        // To get back the correct last stack.\n        last = lastGroup.options ?\n          lastGroup.options[lastGroup.options.length - 1] : lastGroup.stack;\n        break;\n\n\n      // Use pipe character to give more choices.\n      case '|':\n        // Create array where options are if this is the first PIPE\n        // in this clause.\n        if (!lastGroup.options) {\n          lastGroup.options = [lastGroup.stack];\n          delete lastGroup.stack;\n        }\n\n        // Create a new stack and add to options for rest of clause.\n        var stack = [];\n        lastGroup.options.push(stack);\n        last = stack;\n        break;\n\n\n      // Repetition.\n      // For every repetition, remove last element from last stack\n      // then insert back a RANGE object.\n      // This design is chosen because there could be more than\n      // one repetition symbols in a regex i.e. `a?+{2,3}`.\n      case '{':\n        var rs = /^(\\d+)(,(\\d+)?)?\\}/.exec(str.slice(i)), min, max;\n        if (rs !== null) {\n          if (last.length === 0) {\n            repeatErr(i);\n          }\n          min = parseInt(rs[1], 10);\n          max = rs[2] ? rs[3] ? parseInt(rs[3], 10) : Infinity : min;\n          i += rs[0].length;\n\n          last.push({\n            type: types.REPETITION,\n            min,\n            max,\n            value: last.pop(),\n          });\n        } else {\n          last.push({\n            type: types.CHAR,\n            value: 123,\n          });\n        }\n        break;\n\n      case '?':\n        if (last.length === 0) {\n          repeatErr(i);\n        }\n        last.push({\n          type: types.REPETITION,\n          min: 0,\n          max: 1,\n          value: last.pop(),\n        });\n        break;\n\n      case '+':\n        if (last.length === 0) {\n          repeatErr(i);\n        }\n        last.push({\n          type: types.REPETITION,\n          min: 1,\n          max: Infinity,\n          value: last.pop(),\n        });\n        break;\n\n      case '*':\n        if (last.length === 0) {\n          repeatErr(i);\n        }\n        last.push({\n          type: types.REPETITION,\n          min: 0,\n          max: Infinity,\n          value: last.pop(),\n        });\n        break;\n\n\n      // Default is a character that is not `\\[](){}?+*^$`.\n      default:\n        last.push({\n          type: types.CHAR,\n          value: c.charCodeAt(0),\n        });\n    }\n\n  }\n\n  // Check if any groups have not been closed.\n  if (groupStack.length !== 0) {\n    util.error(regexpStr, 'Unterminated group');\n  }\n\n  return start;\n};\n\nmodule.exports.types = types;\n\n},{\"./positions\":18,\"./sets\":19,\"./types\":20,\"./util\":21}],18:[function(require,module,exports){\nconst types = require('./types');\nexports.wordBoundary = () => ({ type: types.POSITION, value: 'b' });\nexports.nonWordBoundary = () => ({ type: types.POSITION, value: 'B' });\nexports.begin = () => ({ type: types.POSITION, value: '^' });\nexports.end = () => ({ type: types.POSITION, value: '$' });\n\n},{\"./types\":20}],19:[function(require,module,exports){\nconst types = require('./types');\n\nconst INTS = () => [{ type: types.RANGE , from: 48, to: 57 }];\n\nconst WORDS = () => {\n  return [\n    { type: types.CHAR, value: 95 },\n    { type: types.RANGE, from: 97, to: 122 },\n    { type: types.RANGE, from: 65, to: 90 }\n  ].concat(INTS());\n};\n\nconst WHITESPACE = () => {\n  return [\n    { type: types.CHAR, value: 9 },\n    { type: types.CHAR, value: 10 },\n    { type: types.CHAR, value: 11 },\n    { type: types.CHAR, value: 12 },\n    { type: types.CHAR, value: 13 },\n    { type: types.CHAR, value: 32 },\n    { type: types.CHAR, value: 160 },\n    { type: types.CHAR, value: 5760 },\n    { type: types.RANGE, from: 8192, to: 8202 },\n    { type: types.CHAR, value: 8232 },\n    { type: types.CHAR, value: 8233 },\n    { type: types.CHAR, value: 8239 },\n    { type: types.CHAR, value: 8287 },\n    { type: types.CHAR, value: 12288 },\n    { type: types.CHAR, value: 65279 }\n  ];\n};\n\nconst NOTANYCHAR = () => {\n  return [\n    { type: types.CHAR, value: 10 },\n    { type: types.CHAR, value: 13 },\n    { type: types.CHAR, value: 8232 },\n    { type: types.CHAR, value: 8233 },\n  ];\n};\n\n// Predefined class objects.\nexports.words = () => ({ type: types.SET, set: WORDS(), not: false });\nexports.notWords = () => ({ type: types.SET, set: WORDS(), not: true });\nexports.ints = () => ({ type: types.SET, set: INTS(), not: false });\nexports.notInts = () => ({ type: types.SET, set: INTS(), not: true });\nexports.whitespace = () => ({ type: types.SET, set: WHITESPACE(), not: false });\nexports.notWhitespace = () => ({ type: types.SET, set: WHITESPACE(), not: true });\nexports.anyChar = () => ({ type: types.SET, set: NOTANYCHAR(), not: true });\n\n},{\"./types\":20}],20:[function(require,module,exports){\nmodule.exports = {\n  ROOT       : 0,\n  GROUP      : 1,\n  POSITION   : 2,\n  SET        : 3,\n  RANGE      : 4,\n  REPETITION : 5,\n  REFERENCE  : 6,\n  CHAR       : 7,\n};\n\n},{}],21:[function(require,module,exports){\nconst types = require('./types');\nconst sets  = require('./sets');\n\n\nconst CTRL = '@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^ ?';\nconst SLSH = { '0': 0, 't': 9, 'n': 10, 'v': 11, 'f': 12, 'r': 13 };\n\n/**\n * Finds character representations in str and convert all to\n * their respective characters\n *\n * @param {String} str\n * @return {String}\n */\nexports.strToChars = function(str) {\n  /* jshint maxlen: false */\n  var chars_regex = /(\\[\\\\b\\])|(\\\\)?\\\\(?:u([A-F0-9]{4})|x([A-F0-9]{2})|(0?[0-7]{2})|c([@A-Z[\\\\\\]^?])|([0tnvfr]))/g;\n  str = str.replace(chars_regex, function(s, b, lbs, a16, b16, c8, dctrl, eslsh) {\n    if (lbs) {\n      return s;\n    }\n\n    var code = b ? 8 :\n      a16   ? parseInt(a16, 16) :\n      b16   ? parseInt(b16, 16) :\n      c8    ? parseInt(c8,   8) :\n      dctrl ? CTRL.indexOf(dctrl) :\n      SLSH[eslsh];\n\n    var c = String.fromCharCode(code);\n\n    // Escape special regex characters.\n    if (/[[\\]{}^$.|?*+()]/.test(c)) {\n      c = '\\\\' + c;\n    }\n\n    return c;\n  });\n\n  return str;\n};\n\n\n/**\n * turns class into tokens\n * reads str until it encounters a ] not preceeded by a \\\n *\n * @param {String} str\n * @param {String} regexpStr\n * @return {Array.<Array.<Object>, Number>}\n */\nexports.tokenizeClass = (str, regexpStr) => {\n  /* jshint maxlen: false */\n  var tokens = [];\n  var regexp = /\\\\(?:(w)|(d)|(s)|(W)|(D)|(S))|((?:(?:\\\\)(.)|([^\\]\\\\]))-(?:\\\\)?([^\\]]))|(\\])|(?:\\\\)?([^])/g;\n  var rs, c;\n\n\n  while ((rs = regexp.exec(str)) != null) {\n    if (rs[1]) {\n      tokens.push(sets.words());\n\n    } else if (rs[2]) {\n      tokens.push(sets.ints());\n\n    } else if (rs[3]) {\n      tokens.push(sets.whitespace());\n\n    } else if (rs[4]) {\n      tokens.push(sets.notWords());\n\n    } else if (rs[5]) {\n      tokens.push(sets.notInts());\n\n    } else if (rs[6]) {\n      tokens.push(sets.notWhitespace());\n\n    } else if (rs[7]) {\n      tokens.push({\n        type: types.RANGE,\n        from: (rs[8] || rs[9]).charCodeAt(0),\n        to: rs[10].charCodeAt(0),\n      });\n\n    } else if ((c = rs[12])) {\n      tokens.push({\n        type: types.CHAR,\n        value: c.charCodeAt(0),\n      });\n\n    } else {\n      return [tokens, regexp.lastIndex];\n    }\n  }\n\n  exports.error(regexpStr, 'Unterminated character class');\n};\n\n\n/**\n * Shortcut to throw errors.\n *\n * @param {String} regexp\n * @param {String} msg\n */\nexports.error = (regexp, msg) => {\n  throw new SyntaxError('Invalid regular expression: /' + regexp + '/: ' + msg);\n};\n\n},{\"./sets\":19,\"./types\":20}],22:[function(require,module,exports){\n'use strict'\n\nvar parse = require('ret')\nvar types = parse.types\n\nmodule.exports = function (re, opts) {\n  if (!opts) opts = {}\n  var replimit = opts.limit === undefined ? 25 : opts.limit\n\n  if (isRegExp(re)) re = re.source\n  else if (typeof re !== 'string') re = String(re)\n\n  try { re = parse(re) } catch (err) { return false }\n\n  var reps = 0\n  return (function walk (node, starHeight) {\n    var i\n    var ok\n    var len\n\n    if (node.type === types.REPETITION) {\n      starHeight++\n      reps++\n      if (starHeight > 1) return false\n      if (reps > replimit) return false\n    }\n\n    if (node.options) {\n      for (i = 0, len = node.options.length; i < len; i++) {\n        ok = walk({ stack: node.options[i] }, starHeight)\n        if (!ok) return false\n      }\n    }\n    var stack = node.stack || (node.value && node.value.stack)\n    if (!stack) return true\n\n    for (i = 0; i < stack.length; i++) {\n      ok = walk(stack[i], starHeight)\n      if (!ok) return false\n    }\n\n    return true\n  })(re, 0)\n}\n\nfunction isRegExp (x) {\n  return {}.toString.call(x) === '[object RegExp]'\n}\n\n},{\"ret\":17}]},{},[4])(4)\n});\n\n","'use strict'\n\nconst HandlerStorage = require('./handler_storage')\n\nconst NODE_TYPES = {\n  STATIC: 0,\n  PARAMETRIC: 1,\n  WILDCARD: 2\n}\n\nclass Node {\n  constructor () {\n    this.handlerStorage = new HandlerStorage()\n  }\n}\n\nclass ParentNode extends Node {\n  constructor () {\n    super()\n    this.staticChildren = {}\n  }\n\n  findStaticMatchingChild (path, pathIndex) {\n    const staticChild = this.staticChildren[path.charAt(pathIndex)]\n    if (staticChild === undefined || !staticChild.matchPrefix(path, pathIndex)) {\n      return null\n    }\n    return staticChild\n  }\n\n  createStaticChild (path) {\n    if (path.length === 0) {\n      return this\n    }\n\n    let staticChild = this.staticChildren[path.charAt(0)]\n    if (staticChild) {\n      let i = 1\n      for (; i < staticChild.prefix.length; i++) {\n        if (path.charCodeAt(i) !== staticChild.prefix.charCodeAt(i)) {\n          staticChild = staticChild.split(this, i)\n          break\n        }\n      }\n      return staticChild.createStaticChild(path.slice(i))\n    }\n\n    const label = path.charAt(0)\n    this.staticChildren[label] = new StaticNode(path)\n    return this.staticChildren[label]\n  }\n}\n\nclass StaticNode extends ParentNode {\n  constructor (prefix) {\n    super()\n    this.prefix = prefix\n    this.wildcardChild = null\n    this.parametricChildren = []\n    this.kind = NODE_TYPES.STATIC\n    this._compilePrefixMatch()\n  }\n\n  createParametricChild (regex, staticSuffix) {\n    const regexpSource = regex && regex.source\n\n    let parametricChild = this.parametricChildren.find(child => {\n      const childRegexSource = child.regex && child.regex.source\n      return childRegexSource === regexpSource\n    })\n\n    if (parametricChild) {\n      return parametricChild\n    }\n\n    parametricChild = new ParametricNode(regex, staticSuffix)\n    this.parametricChildren.push(parametricChild)\n    this.parametricChildren.sort((child1, child2) => {\n      if (!child1.isRegex) return 1\n      if (!child2.isRegex) return -1\n\n      if (child1.staticSuffix === null) return 1\n      if (child2.staticSuffix === null) return -1\n\n      if (child2.staticSuffix.endsWith(child1.staticSuffix)) return 1\n      if (child1.staticSuffix.endsWith(child2.staticSuffix)) return -1\n\n      return 0\n    })\n\n    return parametricChild\n  }\n\n  createWildcardChild () {\n    if (this.wildcardChild) {\n      return this.wildcardChild\n    }\n\n    this.wildcardChild = new WildcardNode()\n    return this.wildcardChild\n  }\n\n  split (parentNode, length) {\n    const parentPrefix = this.prefix.slice(0, length)\n    const childPrefix = this.prefix.slice(length)\n\n    this.prefix = childPrefix\n    this._compilePrefixMatch()\n\n    const staticNode = new StaticNode(parentPrefix)\n    staticNode.staticChildren[childPrefix.charAt(0)] = this\n    parentNode.staticChildren[parentPrefix.charAt(0)] = staticNode\n\n    return staticNode\n  }\n\n  getNextNode (path, pathIndex, nodeStack, paramsCount) {\n    let node = this.findStaticMatchingChild(path, pathIndex)\n    let parametricBrotherNodeIndex = 0\n\n    if (node === null) {\n      if (this.parametricChildren.length === 0) {\n        return this.wildcardChild\n      }\n\n      node = this.parametricChildren[0]\n      parametricBrotherNodeIndex = 1\n    }\n\n    if (this.wildcardChild !== null) {\n      nodeStack.push({\n        paramsCount,\n        brotherPathIndex: pathIndex,\n        brotherNode: this.wildcardChild\n      })\n    }\n\n    for (let i = this.parametricChildren.length - 1; i >= parametricBrotherNodeIndex; i--) {\n      nodeStack.push({\n        paramsCount,\n        brotherPathIndex: pathIndex,\n        brotherNode: this.parametricChildren[i]\n      })\n    }\n\n    return node\n  }\n\n  _compilePrefixMatch () {\n    if (this.prefix.length === 1) {\n      this.matchPrefix = () => true\n      return\n    }\n\n    const lines = []\n    for (let i = 1; i < this.prefix.length; i++) {\n      const charCode = this.prefix.charCodeAt(i)\n      lines.push(`path.charCodeAt(i + ${i}) === ${charCode}`)\n    }\n    this.matchPrefix = new Function('path', 'i', `return ${lines.join(' && ')}`) // eslint-disable-line\n  }\n}\n\nclass ParametricNode extends ParentNode {\n  constructor (regex, staticSuffix) {\n    super()\n    this.isRegex = !!regex\n    this.regex = regex || null\n    this.staticSuffix = staticSuffix || null\n    this.kind = NODE_TYPES.PARAMETRIC\n  }\n\n  getNextNode (path, pathIndex) {\n    return this.findStaticMatchingChild(path, pathIndex)\n  }\n}\n\nclass WildcardNode extends Node {\n  constructor () {\n    super()\n    this.kind = NODE_TYPES.WILDCARD\n  }\n\n  getNextNode () {\n    return null\n  }\n}\n\nmodule.exports = { StaticNode, ParametricNode, WildcardNode, NODE_TYPES }\n","'use strict'\n\nclass HandlerStorage {\n  constructor () {\n    this.unconstrainedHandler = null // optimized reference to the handler that will match most of the time\n    this.constraints = []\n    this.handlers = [] // unoptimized list of handler objects for which the fast matcher function will be compiled\n    this.constrainedHandlerStores = null\n  }\n\n  // This is the hot path for node handler finding -- change with care!\n  getMatchingHandler (derivedConstraints) {\n    if (derivedConstraints === undefined) {\n      return this.unconstrainedHandler\n    }\n    return this._getHandlerMatchingConstraints(derivedConstraints)\n  }\n\n  addHandler (handler, params, store, constrainer, constraints) {\n    const handlerObject = {\n      handler,\n      params,\n      constraints,\n      store: store || null,\n      _createParamsObject: this._compileCreateParamsObject(params)\n    }\n\n    if (Object.keys(constraints).length === 0) {\n      this.unconstrainedHandler = handlerObject\n    }\n\n    for (const constraint of Object.keys(constraints)) {\n      if (!this.constraints.includes(constraint)) {\n        if (constraint === 'version') {\n          // always check the version constraint first as it is the most selective\n          this.constraints.unshift(constraint)\n        } else {\n          this.constraints.push(constraint)\n        }\n      }\n    }\n\n    if (this.handlers.length >= 32) {\n      throw new Error('find-my-way supports a maximum of 32 route handlers per node when there are constraints, limit reached')\n    }\n\n    this.handlers.push(handlerObject)\n    // Sort the most constrained handlers to the front of the list of handlers so they are tested first.\n    this.handlers.sort((a, b) => Object.keys(a.constraints).length - Object.keys(b.constraints).length)\n\n    this._compileGetHandlerMatchingConstraints(constrainer, constraints)\n  }\n\n  _compileCreateParamsObject (params) {\n    const lines = []\n    for (let i = 0; i < params.length; i++) {\n      lines.push(`'${params[i]}': paramsArray[${i}]`)\n    }\n    return new Function('paramsArray', `return {${lines.join(',')}}`)  // eslint-disable-line\n  }\n\n  _getHandlerMatchingConstraints () {\n    return null\n  }\n\n  // Builds a store object that maps from constraint values to a bitmap of handler indexes which pass the constraint for a value\n  // So for a host constraint, this might look like { \"fastify.io\": 0b0010, \"google.ca\": 0b0101 }, meaning the 3rd handler is constrainted to fastify.io, and the 2nd and 4th handlers are constrained to google.ca.\n  // The store's implementation comes from the strategies provided to the Router.\n  _buildConstraintStore (store, constraint) {\n    for (let i = 0; i < this.handlers.length; i++) {\n      const handler = this.handlers[i]\n      const constraintValue = handler.constraints[constraint]\n      if (constraintValue !== undefined) {\n        let indexes = store.get(constraintValue) || 0\n        indexes |= 1 << i // set the i-th bit for the mask because this handler is constrained by this value https://stackoverflow.com/questions/1436438/how-do-you-set-clear-and-toggle-a-single-bit-in-javascrip\n        store.set(constraintValue, indexes)\n      }\n    }\n  }\n\n  // Builds a bitmask for a given constraint that has a bit for each handler index that is 0 when that handler *is* constrained and 1 when the handler *isnt* constrainted. This is opposite to what might be obvious, but is just for convienience when doing the bitwise operations.\n  _constrainedIndexBitmask (constraint) {\n    let mask = 0\n    for (let i = 0; i < this.handlers.length; i++) {\n      const handler = this.handlers[i]\n      const constraintValue = handler.constraints[constraint]\n      if (constraintValue !== undefined) {\n        mask |= 1 << i\n      }\n    }\n    return ~mask\n  }\n\n  // Compile a fast function to match the handlers for this node\n  // The function implements a general case multi-constraint matching algorithm.\n  // The general idea is this: we have a bunch of handlers, each with a potentially different set of constraints, and sometimes none at all. We're given a list of constraint values and we have to use the constraint-value-comparison strategies to see which handlers match the constraint values passed in.\n  // We do this by asking each constraint store which handler indexes match the given constraint value for each store. Trickily, the handlers that a store says match are the handlers constrained by that store, but handlers that aren't constrained at all by that store could still match just fine. So, each constraint store can only describe matches for it, and it won't have any bearing on the handlers it doesn't care about. For this reason, we have to ask each stores which handlers match and track which have been matched (or not cared about) by all of them.\n  // We use bitmaps to represent these lists of matches so we can use bitwise operations to implement this efficiently. Bitmaps are cheap to allocate, let us implement this masking behaviour in one CPU instruction, and are quite compact in memory. We start with a bitmap set to all 1s representing every handler that is a match candidate, and then for each constraint, see which handlers match using the store, and then mask the result by the mask of handlers that that store applies to, and bitwise AND with the candidate list. Phew.\n  // We consider all this compiling function complexity to be worth it, because the naive implementation that just loops over the handlers asking which stores match is quite a bit slower.\n  _compileGetHandlerMatchingConstraints (constrainer) {\n    this.constrainedHandlerStores = {}\n\n    for (const constraint of this.constraints) {\n      const store = constrainer.newStoreForConstraint(constraint)\n      this.constrainedHandlerStores[constraint] = store\n\n      this._buildConstraintStore(store, constraint)\n    }\n\n    const lines = []\n    lines.push(`\n    let candidates = ${(1 << this.handlers.length) - 1}\n    let mask, matches\n    `)\n    for (const constraint of this.constraints) {\n      // Setup the mask for indexes this constraint applies to. The mask bits are set to 1 for each position if the constraint applies.\n      lines.push(`\n      mask = ${this._constrainedIndexBitmask(constraint)}\n      value = derivedConstraints.${constraint}\n      `)\n\n      // If there's no constraint value, none of the handlers constrained by this constraint can match. Remove them from the candidates.\n      // If there is a constraint value, get the matching indexes bitmap from the store, and mask it down to only the indexes this constraint applies to, and then bitwise and with the candidates list to leave only matching candidates left.\n      const strategy = constrainer.strategies[constraint]\n      const matchMask = strategy.mustMatchWhenDerived ? 'matches' : '(matches | mask)'\n\n      lines.push(`\n      if (value === undefined) {\n        candidates &= mask\n      } else {\n        matches = this.constrainedHandlerStores.${constraint}.get(value) || 0\n        candidates &= ${matchMask}\n      }\n      if (candidates === 0) return null;\n      `)\n    }\n\n    // There are some constraints that can be derived and marked as \"must match\", where if they are derived, they only match routes that actually have a constraint on the value, like the SemVer version constraint.\n    // An example: a request comes in for version 1.x, and this node has a handler that matches the path, but there's no version constraint. For SemVer, the find-my-way semantics do not match this handler to that request.\n    // This function is used by Nodes with handlers to match when they don't have any constrained routes to exclude request that do have must match derived constraints present.\n    for (const constraint in constrainer.strategies) {\n      const strategy = constrainer.strategies[constraint]\n      if (strategy.mustMatchWhenDerived && !this.constraints.includes(constraint)) {\n        lines.push(`if (derivedConstraints.${constraint} !== undefined) return null`)\n      }\n    }\n\n    // Return the first handler who's bit is set in the candidates https://stackoverflow.com/questions/18134985/how-to-find-index-of-first-set-bit\n    lines.push('return this.handlers[Math.floor(Math.log2(candidates))]')\n\n    this._getHandlerMatchingConstraints = new Function('derivedConstraints', lines.join('\\n')) // eslint-disable-line\n  }\n}\n\nmodule.exports = HandlerStorage\n","'use strict'\n\n/*\n  Char codes:\n    '!': 33 - !\n    '#': 35 - %23\n    '$': 36 - %24\n    '%': 37 - %25\n    '&': 38 - %26\n    ''': 39 - '\n    '(': 40 - (\n    ')': 41 - )\n    '*': 42 - *\n    '+': 43 - %2B\n    ',': 44 - %2C\n    '-': 45 - -\n    '.': 46 - .\n    '/': 47 - %2F\n    ':': 58 - %3A\n    ';': 59 - %3B\n    '=': 61 - %3D\n    '?': 63 - %3F\n    '@': 64 - %40\n    '_': 95 - _\n    '~': 126 - ~\n*/\n\nconst assert = require('./assert-mock.js')\nconst querystring = require('fast-querystring')\nconst isRegexSafe = require('safe-regex2')\nconst deepEqual = require('fast-deep-equal')\nconst { flattenNode, compressFlattenedNode, prettyPrintFlattenedNode, prettyPrintRoutesArray } = require('./lib/pretty-print')\nconst { StaticNode, NODE_TYPES } = require('./custom_node')\nconst Constrainer = require('./lib/constrainer')\nconst httpMethods = require('./lib/http-methods')\nconst { safeDecodeURI, safeDecodeURIComponent } = require('./lib/url-sanitizer')\n\nconst FULL_PATH_REGEXP = /^https?:\\/\\/.*?\\//\nconst OPTIONAL_PARAM_REGEXP = /(\\/:[^/()]*?)\\?(\\/?)/\n\nif (!isRegexSafe(FULL_PATH_REGEXP)) {\n  throw new Error('the FULL_PATH_REGEXP is not safe, update this module')\n}\n\nif (!isRegexSafe(OPTIONAL_PARAM_REGEXP)) {\n  throw new Error('the OPTIONAL_PARAM_REGEXP is not safe, update this module')\n}\n\nfunction Router (opts) {\n  if (!(this instanceof Router)) {\n    return new Router(opts)\n  }\n  opts = opts || {}\n\n  if (opts.defaultRoute) {\n    assert(typeof opts.defaultRoute === 'function', 'The default route must be a function')\n    this.defaultRoute = opts.defaultRoute\n  } else {\n    this.defaultRoute = null\n  }\n\n  if (opts.onBadUrl) {\n    assert(typeof opts.onBadUrl === 'function', 'The bad url handler must be a function')\n    this.onBadUrl = opts.onBadUrl\n  } else {\n    this.onBadUrl = null\n  }\n\n  if (opts.buildPrettyMeta) {\n    assert(typeof opts.buildPrettyMeta === 'function', 'buildPrettyMeta must be a function')\n    this.buildPrettyMeta = opts.buildPrettyMeta\n  } else {\n    this.buildPrettyMeta = defaultBuildPrettyMeta\n  }\n\n  if (opts.querystringParser) {\n    assert(typeof opts.querystringParser === 'function', 'querystringParser must be a function')\n    this.querystringParser = opts.querystringParser\n  } else {\n    this.querystringParser = (query) => query === '' ? {} : querystring.parse(query)\n  }\n\n  this.caseSensitive = opts.caseSensitive === undefined ? true : opts.caseSensitive\n  this.ignoreTrailingSlash = opts.ignoreTrailingSlash || false\n  this.ignoreDuplicateSlashes = opts.ignoreDuplicateSlashes || false\n  this.maxParamLength = opts.maxParamLength || 100\n  this.allowUnsafeRegex = opts.allowUnsafeRegex || false\n  this.routes = []\n  this.trees = {}\n  this.constrainer = new Constrainer(opts.constraints)\n\n  this._routesPatterns = {}\n}\n\nRouter.prototype.on = function on (method, path, opts, handler, store) {\n  if (typeof opts === 'function') {\n    if (handler !== undefined) {\n      store = handler\n    }\n    handler = opts\n    opts = {}\n  }\n  // path validation\n  assert(typeof path === 'string', 'Path should be a string')\n  assert(path.length > 0, 'The path could not be empty')\n  assert(path[0] === '/' || path[0] === '*', 'The first character of a path should be `/` or `*`')\n  // handler validation\n  assert(typeof handler === 'function', 'Handler should be a function')\n\n  // path ends with optional parameter\n  const optionalParamMatch = path.match(OPTIONAL_PARAM_REGEXP)\n  if (optionalParamMatch) {\n    assert(path.length === optionalParamMatch.index + optionalParamMatch[0].length, 'Optional Parameter needs to be the last parameter of the path')\n\n    const pathFull = path.replace(OPTIONAL_PARAM_REGEXP, '$1$2')\n    const pathOptional = path.replace(OPTIONAL_PARAM_REGEXP, '$2')\n\n    this.on(method, pathFull, opts, handler, store)\n    this.on(method, pathOptional, opts, handler, store)\n    return\n  }\n\n  const route = path\n\n  if (this.ignoreDuplicateSlashes) {\n    path = removeDuplicateSlashes(path)\n  }\n\n  if (this.ignoreTrailingSlash) {\n    path = trimLastSlash(path)\n  }\n\n  const methods = Array.isArray(method) ? method : [method]\n  for (const method of methods) {\n    this._on(method, path, opts, handler, store, route)\n    this.routes.push({ method, path, opts, handler, store })\n  }\n}\n\nRouter.prototype._on = function _on (method, path, opts, handler, store) {\n  assert(typeof method === 'string', 'Method should be a string')\n  assert(httpMethods.includes(method), `Method '${method}' is not an http method.`)\n\n  let constraints = {}\n  if (opts.constraints !== undefined) {\n    assert(typeof opts.constraints === 'object' && opts.constraints !== null, 'Constraints should be an object')\n    if (Object.keys(opts.constraints).length !== 0) {\n      constraints = opts.constraints\n    }\n  }\n\n  this.constrainer.validateConstraints(constraints)\n  // Let the constrainer know if any constraints are being used now\n  this.constrainer.noteUsage(constraints)\n\n  // Boot the tree for this method if it doesn't exist yet\n  if (this.trees[method] === undefined) {\n    this.trees[method] = new StaticNode('/')\n    this._routesPatterns[method] = []\n  }\n\n  if (path === '*' && this.trees[method].prefix.length !== 0) {\n    const currentRoot = this.trees[method]\n    this.trees[method] = new StaticNode('')\n    this.trees[method].staticChildren['/'] = currentRoot\n  }\n\n  let currentNode = this.trees[method]\n  let parentNodePathIndex = currentNode.prefix.length\n\n  const params = []\n  for (let i = 0; i <= path.length; i++) {\n    if (path.charCodeAt(i) === 58 && path.charCodeAt(i + 1) === 58) {\n      // It's a double colon\n      i++\n      continue\n    }\n\n    const isParametricNode = path.charCodeAt(i) === 58 && path.charCodeAt(i + 1) !== 58\n    const isWildcardNode = path.charCodeAt(i) === 42\n\n    if (isParametricNode || isWildcardNode || (i === path.length && i !== parentNodePathIndex)) {\n      let staticNodePath = path.slice(parentNodePathIndex, i)\n      if (!this.caseSensitive) {\n        staticNodePath = staticNodePath.toLowerCase()\n      }\n      staticNodePath = staticNodePath.split('::').join(':')\n      staticNodePath = staticNodePath.split('%').join('%25')\n      // add the static part of the route to the tree\n      currentNode = currentNode.createStaticChild(staticNodePath)\n    }\n\n    if (isParametricNode) {\n      let isRegexNode = false\n      const regexps = []\n\n      let lastParamStartIndex = i + 1\n      for (let j = lastParamStartIndex; ; j++) {\n        const charCode = path.charCodeAt(j)\n\n        const isRegexParam = charCode === 40\n        const isStaticPart = charCode === 45 || charCode === 46\n        const isEndOfNode = charCode === 47 || j === path.length\n\n        if (isRegexParam || isStaticPart || isEndOfNode) {\n          const paramName = path.slice(lastParamStartIndex, j)\n          params.push(paramName)\n\n          isRegexNode = isRegexNode || isRegexParam || isStaticPart\n\n          if (isRegexParam) {\n            const endOfRegexIndex = getClosingParenthensePosition(path, j)\n            const regexString = path.slice(j, endOfRegexIndex + 1)\n\n            if (!this.allowUnsafeRegex) {\n              assert(isRegexSafe(new RegExp(regexString)), `The regex '${regexString}' is not safe!`)\n            }\n\n            regexps.push(trimRegExpStartAndEnd(regexString))\n\n            j = endOfRegexIndex + 1\n          } else {\n            regexps.push('(.*?)')\n          }\n\n          const staticPartStartIndex = j\n          for (; j < path.length; j++) {\n            const charCode = path.charCodeAt(j)\n            if (charCode === 47) break\n            if (charCode === 58) {\n              const nextCharCode = path.charCodeAt(j + 1)\n              if (nextCharCode === 58) j++\n              else break\n            }\n          }\n\n          let staticPart = path.slice(staticPartStartIndex, j)\n          if (staticPart) {\n            staticPart = staticPart.split('::').join(':')\n            staticPart = staticPart.split('%').join('%25')\n            regexps.push(escapeRegExp(staticPart))\n          }\n\n          lastParamStartIndex = j + 1\n\n          if (isEndOfNode || path.charCodeAt(j) === 47 || j === path.length) {\n            const nodePattern = isRegexNode ? '()' + staticPart : staticPart\n\n            path = path.slice(0, i + 1) + nodePattern + path.slice(j)\n            i += nodePattern.length\n\n            const regex = isRegexNode ? new RegExp('^' + regexps.join('') + '$') : null\n            currentNode = currentNode.createParametricChild(regex, staticPart || null)\n            parentNodePathIndex = i + 1\n            break\n          }\n        }\n      }\n    } else if (isWildcardNode) {\n      // add the wildcard parameter\n      params.push('*')\n      currentNode = currentNode.createWildcardChild()\n      parentNodePathIndex = i + 1\n\n      if (i !== path.length - 1) {\n        throw new Error('Wildcard must be the last character in the route')\n      }\n    }\n  }\n\n  if (!this.caseSensitive) {\n    path = path.toLowerCase()\n  }\n\n  if (path === '*') {\n    path = '/*'\n  }\n\n  for (const existRoute of this._routesPatterns[method]) {\n    if (existRoute.path === path && deepEqual(existRoute.constraints, constraints)) {\n      throw new Error(`Method '${method}' already declared for route '${path}' with constraints '${JSON.stringify(constraints)}'`)\n    }\n  }\n  this._routesPatterns[method].push({ path, params, constraints })\n\n  currentNode.handlerStorage.addHandler(handler, params, store, this.constrainer, constraints)\n}\n\nRouter.prototype.hasConstraintStrategy = function (strategyName) {\n  return this.constrainer.hasConstraintStrategy(strategyName)\n}\n\nRouter.prototype.addConstraintStrategy = function (constraints) {\n  this.constrainer.addConstraintStrategy(constraints)\n  this._rebuild(this.routes)\n}\n\nRouter.prototype.reset = function reset () {\n  this.trees = {}\n  this.routes = []\n  this._routesPatterns = {}\n}\n\nRouter.prototype.off = function off (method, path, constraints) {\n  // path validation\n  assert(typeof path === 'string', 'Path should be a string')\n  assert(path.length > 0, 'The path could not be empty')\n  assert(path[0] === '/' || path[0] === '*', 'The first character of a path should be `/` or `*`')\n  // options validation\n  assert(\n    typeof constraints === 'undefined' ||\n    (typeof constraints === 'object' && !Array.isArray(constraints) && constraints !== null),\n    'Constraints should be an object or undefined.')\n\n  // path ends with optional parameter\n  const optionalParamMatch = path.match(OPTIONAL_PARAM_REGEXP)\n  if (optionalParamMatch) {\n    assert(path.length === optionalParamMatch.index + optionalParamMatch[0].length, 'Optional Parameter needs to be the last parameter of the path')\n\n    const pathFull = path.replace(OPTIONAL_PARAM_REGEXP, '$1$2')\n    const pathOptional = path.replace(OPTIONAL_PARAM_REGEXP, '$2')\n\n    this.off(method, pathFull, constraints)\n    this.off(method, pathOptional, constraints)\n    return\n  }\n\n  if (this.ignoreDuplicateSlashes) {\n    path = removeDuplicateSlashes(path)\n  }\n\n  if (this.ignoreTrailingSlash) {\n    path = trimLastSlash(path)\n  }\n\n  const methods = Array.isArray(method) ? method : [method]\n  for (const method of methods) {\n    this._off(method, path, constraints)\n  }\n}\n\nRouter.prototype._off = function _off (method, path, constraints) {\n  // method validation\n  assert(typeof method === 'string', 'Method should be a string')\n  assert(httpMethods.includes(method), `Method '${method}' is not an http method.`)\n\n  function matcherWithoutConstraints (route) {\n    return method !== route.method || path !== route.path\n  }\n\n  function matcherWithConstraints (route) {\n    return matcherWithoutConstraints(route) || !deepEqual(constraints, route.opts.constraints || {})\n  }\n\n  const predicate = constraints ? matcherWithConstraints : matcherWithoutConstraints\n\n  // Rebuild tree without the specific route\n  const newRoutes = this.routes.filter(predicate)\n  this._rebuild(newRoutes)\n}\n\nRouter.prototype.lookup = function lookup (req, res, ctx, done) {\n  if (typeof ctx === 'function') {\n    done = ctx\n    ctx = undefined\n  }\n\n  if (done === undefined) {\n    const constraints = this.constrainer.deriveConstraints(req, ctx)\n    const handle = this.find(req.method, req.url, constraints)\n    return this.callHandler(handle, req, res, ctx)\n  }\n\n  this.constrainer.deriveConstraints(req, ctx, (err, constraints) => {\n    if (err !== null) {\n      done(err)\n      return\n    }\n\n    try {\n      const handle = this.find(req.method, req.url, constraints)\n      const result = this.callHandler(handle, req, res, ctx)\n      done(null, result)\n    } catch (err) {\n      done(err)\n    }\n  })\n}\n\nRouter.prototype.callHandler = function callHandler (handle, req, res, ctx) {\n  if (handle === null) return this._defaultRoute(req, res, ctx)\n  return ctx === undefined\n    ? handle.handler(req, res, handle.params, handle.store, handle.searchParams)\n    : handle.handler.call(ctx, req, res, handle.params, handle.store, handle.searchParams)\n}\n\nRouter.prototype.find = function find (method, path, derivedConstraints) {\n  let currentNode = this.trees[method]\n  if (currentNode === undefined) return null\n\n  if (path.charCodeAt(0) !== 47) { // 47 is '/'\n    path = path.replace(FULL_PATH_REGEXP, '/')\n  }\n\n  // This must be run before sanitizeUrl as the resulting function\n  // .sliceParameter must be constructed with same URL string used\n  // throughout the rest of this function.\n  if (this.ignoreDuplicateSlashes) {\n    path = removeDuplicateSlashes(path)\n  }\n\n  let sanitizedUrl\n  let querystring\n  let shouldDecodeParam\n\n  try {\n    sanitizedUrl = safeDecodeURI(path)\n    path = sanitizedUrl.path\n    querystring = sanitizedUrl.querystring\n    shouldDecodeParam = sanitizedUrl.shouldDecodeParam\n  } catch (error) {\n    return this._onBadUrl(path)\n  }\n\n  if (this.ignoreTrailingSlash) {\n    path = trimLastSlash(path)\n  }\n\n  const originPath = path\n\n  if (this.caseSensitive === false) {\n    path = path.toLowerCase()\n  }\n\n  const maxParamLength = this.maxParamLength\n\n  let pathIndex = currentNode.prefix.length\n  const params = []\n  const pathLen = path.length\n\n  const brothersNodesStack = []\n\n  while (true) {\n    if (pathIndex === pathLen) {\n      const handle = currentNode.handlerStorage.getMatchingHandler(derivedConstraints)\n\n      if (handle !== null) {\n        return {\n          handler: handle.handler,\n          store: handle.store,\n          params: handle._createParamsObject(params),\n          searchParams: this.querystringParser(querystring)\n        }\n      }\n    }\n\n    let node = currentNode.getNextNode(path, pathIndex, brothersNodesStack, params.length)\n\n    if (node === null) {\n      if (brothersNodesStack.length === 0) {\n        return null\n      }\n\n      const brotherNodeState = brothersNodesStack.pop()\n      pathIndex = brotherNodeState.brotherPathIndex\n      params.splice(brotherNodeState.paramsCount)\n      node = brotherNodeState.brotherNode\n    }\n\n    currentNode = node\n\n    // static route\n    if (currentNode.kind === NODE_TYPES.STATIC) {\n      pathIndex += currentNode.prefix.length\n      continue\n    }\n\n    if (currentNode.kind === NODE_TYPES.WILDCARD) {\n      let param = originPath.slice(pathIndex)\n      if (shouldDecodeParam) {\n        param = safeDecodeURIComponent(param)\n      }\n\n      params.push(param)\n      pathIndex = pathLen\n      continue\n    }\n\n    if (currentNode.kind === NODE_TYPES.PARAMETRIC) {\n      let paramEndIndex = originPath.indexOf('/', pathIndex)\n      if (paramEndIndex === -1) {\n        paramEndIndex = pathLen\n      }\n\n      let param = originPath.slice(pathIndex, paramEndIndex)\n      if (shouldDecodeParam) {\n        param = safeDecodeURIComponent(param)\n      }\n\n      if (currentNode.isRegex) {\n        const matchedParameters = currentNode.regex.exec(param)\n        if (matchedParameters === null) continue\n\n        for (let i = 1; i < matchedParameters.length; i++) {\n          const matchedParam = matchedParameters[i]\n          if (matchedParam.length > maxParamLength) {\n            return null\n          }\n          params.push(matchedParam)\n        }\n      } else {\n        if (param.length > maxParamLength) {\n          return null\n        }\n        params.push(param)\n      }\n\n      pathIndex = paramEndIndex\n    }\n  }\n}\n\nRouter.prototype._rebuild = function (routes) {\n  this.reset()\n\n  for (const route of routes) {\n    const { method, path, opts, handler, store } = route\n    this._on(method, path, opts, handler, store)\n    this.routes.push({ method, path, opts, handler, store })\n  }\n}\n\nRouter.prototype._defaultRoute = function (req, res, ctx) {\n  if (this.defaultRoute !== null) {\n    return ctx === undefined\n      ? this.defaultRoute(req, res)\n      : this.defaultRoute.call(ctx, req, res)\n  } else {\n    res.statusCode = 404\n    res.end()\n  }\n}\n\nRouter.prototype._onBadUrl = function (path) {\n  if (this.onBadUrl === null) {\n    return null\n  }\n  const onBadUrl = this.onBadUrl\n  return {\n    handler: (req, res, ctx) => onBadUrl(path, req, res),\n    params: {},\n    store: null\n  }\n}\n\nRouter.prototype.prettyPrint = function (opts = {}) {\n  opts.commonPrefix = opts.commonPrefix === undefined ? true : opts.commonPrefix // default to original behaviour\n  if (!opts.commonPrefix) return prettyPrintRoutesArray.call(this, this.routes, opts)\n  const root = {\n    prefix: '/',\n    nodes: [],\n    children: {}\n  }\n\n  for (const method in this.trees) {\n    const node = this.trees[method]\n    if (node) {\n      flattenNode(root, node, method)\n    }\n  }\n\n  compressFlattenedNode(root)\n\n  return prettyPrintFlattenedNode.call(this, root, '', true, opts)\n}\n\nfor (var i in httpMethods) {\n  /* eslint no-prototype-builtins: \"off\" */\n  if (!httpMethods.hasOwnProperty(i)) continue\n  const m = httpMethods[i]\n  const methodName = m.toLowerCase()\n\n  if (Router.prototype[methodName]) throw new Error('Method already exists: ' + methodName)\n\n  Router.prototype[methodName] = function (path, handler, store) {\n    return this.on(m, path, handler, store)\n  }\n}\n\nRouter.prototype.all = function (path, handler, store) {\n  this.on(httpMethods, path, handler, store)\n}\n\nmodule.exports = Router\n\nfunction escapeRegExp (string) {\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')\n}\n\nfunction removeDuplicateSlashes (path) {\n  return path.replace(/\\/\\/+/g, '/')\n}\n\nfunction trimLastSlash (path) {\n  if (path.length > 1 && path.charCodeAt(path.length - 1) === 47) {\n    return path.slice(0, -1)\n  }\n  return path\n}\n\nfunction trimRegExpStartAndEnd (regexString) {\n  // removes chars that marks start \"^\" and end \"$\" of regexp\n  if (regexString.charCodeAt(1) === 94) {\n    regexString = regexString.slice(0, 1) + regexString.slice(2)\n  }\n\n  if (regexString.charCodeAt(regexString.length - 2) === 36) {\n    regexString = regexString.slice(0, regexString.length - 2) + regexString.slice(regexString.length - 1)\n  }\n\n  return regexString\n}\n\nfunction getClosingParenthensePosition (path, idx) {\n  // `path.indexOf()` will always return the first position of the closing parenthese,\n  // but it's inefficient for grouped or wrong regexp expressions.\n  // see issues #62 and #63 for more info\n\n  var parentheses = 1\n\n  while (idx < path.length) {\n    idx++\n\n    // ignore skipped chars\n    if (path[idx] === '\\\\') {\n      idx++\n      continue\n    }\n\n    if (path[idx] === ')') {\n      parentheses--\n    } else if (path[idx] === '(') {\n      parentheses++\n    }\n\n    if (!parentheses) return idx\n  }\n\n  throw new TypeError('Invalid regexp expression in \"' + path + '\"')\n}\n\nfunction defaultBuildPrettyMeta (route) {\n  // buildPrettyMeta function must return an object, which will be parsed into key/value pairs for display\n  if (!route) return {}\n  if (!route.store) return {}\n  return Object.assign({}, route.store)\n}\n","'use strict'\n\nconst acceptVersionStrategy = require('./strategies/accept-version')\nconst acceptHostStrategy = require('./strategies/accept-host')\nconst assert = require('../assert-mock.js')\n\nclass Constrainer {\n  constructor (customStrategies) {\n    this.strategies = {\n      version: acceptVersionStrategy,\n      host: acceptHostStrategy\n    }\n\n    this.strategiesInUse = new Set()\n    this.asyncStrategiesInUse = new Set()\n\n    // validate and optimize prototypes of given custom strategies\n    if (customStrategies) {\n      for (const strategy of Object.values(customStrategies)) {\n        this.addConstraintStrategy(strategy)\n      }\n    }\n  }\n\n  isStrategyUsed (strategyName) {\n    return this.strategiesInUse.has(strategyName) ||\n      this.asyncStrategiesInUse.has(strategyName)\n  }\n\n  hasConstraintStrategy (strategyName) {\n    const customConstraintStrategy = this.strategies[strategyName]\n    if (customConstraintStrategy !== undefined) {\n      return customConstraintStrategy.isCustom ||\n        this.isStrategyUsed(strategyName)\n    }\n    return false\n  }\n\n  addConstraintStrategy (strategy) {\n    assert(typeof strategy.name === 'string' && strategy.name !== '', 'strategy.name is required.')\n    assert(strategy.storage && typeof strategy.storage === 'function', 'strategy.storage function is required.')\n    assert(strategy.deriveConstraint && typeof strategy.deriveConstraint === 'function', 'strategy.deriveConstraint function is required.')\n\n    if (this.strategies[strategy.name] && this.strategies[strategy.name].isCustom) {\n      throw new Error(`There already exists a custom constraint with the name ${strategy.name}.`)\n    }\n\n    if (this.isStrategyUsed(strategy.name)) {\n      throw new Error(`There already exists a route with ${strategy.name} constraint.`)\n    }\n\n    strategy.isCustom = true\n    strategy.isAsync = strategy.deriveConstraint.length === 3\n    this.strategies[strategy.name] = strategy\n\n    if (strategy.mustMatchWhenDerived) {\n      this.noteUsage({ [strategy.name]: strategy })\n    }\n  }\n\n  deriveConstraints (req, ctx, done) {\n    const constraints = this.deriveSyncConstraints(req, ctx)\n\n    if (done === undefined) {\n      return constraints\n    }\n\n    this.deriveAsyncConstraints(constraints, req, ctx, done)\n  }\n\n  deriveSyncConstraints (req, ctx) {\n    return undefined\n  }\n\n  // When new constraints start getting used, we need to rebuild the deriver to derive them. Do so if we see novel constraints used.\n  noteUsage (constraints) {\n    if (constraints) {\n      const beforeSize = this.strategiesInUse.size\n      for (const key in constraints) {\n        const strategy = this.strategies[key]\n        if (strategy.isAsync) {\n          this.asyncStrategiesInUse.add(key)\n        } else {\n          this.strategiesInUse.add(key)\n        }\n      }\n      if (beforeSize !== this.strategiesInUse.size) {\n        this._buildDeriveConstraints()\n      }\n    }\n  }\n\n  newStoreForConstraint (constraint) {\n    if (!this.strategies[constraint]) {\n      throw new Error(`No strategy registered for constraint key ${constraint}`)\n    }\n    return this.strategies[constraint].storage()\n  }\n\n  validateConstraints (constraints) {\n    for (const key in constraints) {\n      const value = constraints[key]\n      if (typeof value === 'undefined') {\n        throw new Error('Can\\'t pass an undefined constraint value, must pass null or no key at all')\n      }\n      const strategy = this.strategies[key]\n      if (!strategy) {\n        throw new Error(`No strategy registered for constraint key ${key}`)\n      }\n      if (strategy.validate) {\n        strategy.validate(value)\n      }\n    }\n  }\n\n  deriveAsyncConstraints (constraints, req, ctx, done) {\n    let asyncConstraintsCount = this.asyncStrategiesInUse.size\n\n    if (asyncConstraintsCount === 0) {\n      done(null, constraints)\n      return\n    }\n\n    constraints = constraints || {}\n    for (const key of this.asyncStrategiesInUse) {\n      const strategy = this.strategies[key]\n      strategy.deriveConstraint(req, ctx, (err, constraintValue) => {\n        if (err !== null) {\n          done(err)\n          return\n        }\n\n        constraints[key] = constraintValue\n\n        if (--asyncConstraintsCount === 0) {\n          done(null, constraints)\n        }\n      })\n    }\n  }\n\n  // Optimization: build a fast function for deriving the constraints for all the strategies at once. We inline the definitions of the version constraint and the host constraint for performance.\n  // If no constraining strategies are in use (no routes constrain on host, or version, or any custom strategies) then we don't need to derive constraints for each route match, so don't do anything special, and just return undefined\n  // This allows us to not allocate an object to hold constraint values if no constraints are defined.\n  _buildDeriveConstraints () {\n    if (this.strategiesInUse.size === 0) return\n\n    const lines = ['return {']\n\n    for (const key of this.strategiesInUse) {\n      const strategy = this.strategies[key]\n      // Optimization: inline the derivation for the common built in constraints\n      if (!strategy.isCustom) {\n        if (key === 'version') {\n          lines.push('   version: req.headers[\\'accept-version\\'],')\n        } else if (key === 'host') {\n          lines.push('   host: req.headers.host || req.headers[\\':authority\\'],')\n        } else {\n          throw new Error('unknown non-custom strategy for compiling constraint derivation function')\n        }\n      } else {\n        lines.push(`  ${strategy.name}: this.strategies.${key}.deriveConstraint(req, ctx),`)\n      }\n    }\n\n    lines.push('}')\n\n    this.deriveSyncConstraints = new Function('req', 'ctx', lines.join('\\n')).bind(this) // eslint-disable-line\n  }\n}\n\nmodule.exports = Constrainer\n","'use strict'\n\n// defined by Node.js http module, a snapshot from Node.js 18.12.0\nconst httpMethods = [\n  'ACL', 'BIND', 'CHECKOUT', 'CONNECT', 'COPY', 'DELETE',\n  'GET', 'HEAD', 'LINK', 'LOCK', 'M-SEARCH', 'MERGE',\n  'MKACTIVITY', 'MKCALENDAR', 'MKCOL', 'MOVE', 'NOTIFY', 'OPTIONS',\n  'PATCH', 'POST', 'PROPFIND', 'PROPPATCH', 'PURGE', 'PUT',\n  'REBIND', 'REPORT', 'SEARCH', 'SOURCE', 'SUBSCRIBE', 'TRACE',\n  'UNBIND', 'UNLINK', 'UNLOCK', 'UNSUBSCRIBE'\n]\n\nmodule.exports = httpMethods\n","'use strict'\n\n/* eslint-disable no-multi-spaces */\nconst indent              = '    '\nconst branchIndent        = '│   '\nconst midBranchIndent     = '├── '\nconst endBranchIndent     = '└── '\nconst wildcardDelimiter   = '*'\nconst pathDelimiter       = '/'\nconst pathRegExp          = /(?=\\/)/\n/* eslint-enable */\n\nfunction parseFunctionName (fn) {\n  let fName = fn.name || ''\n\n  fName = fName.replace('bound', '').trim()\n  fName = (fName || 'anonymous') + '()'\n  return fName\n}\n\nfunction parseMeta (meta) {\n  if (Array.isArray(meta)) return meta.map(m => parseMeta(m))\n  if (typeof meta === 'symbol') return meta.toString()\n  if (typeof meta === 'function') return parseFunctionName(meta)\n  return meta\n}\n\nfunction buildMetaObject (route, metaArray) {\n  const out = {}\n  const cleanMeta = this.buildPrettyMeta(route)\n  if (!Array.isArray(metaArray)) metaArray = cleanMeta ? Reflect.ownKeys(cleanMeta) : []\n  metaArray.forEach(m => {\n    const metaKey = typeof m === 'symbol' ? m.toString() : m\n    if (cleanMeta && cleanMeta[m]) {\n      out[metaKey] = parseMeta(cleanMeta[m])\n    }\n  })\n  return out\n}\n\nfunction prettyPrintRoutesArray (routeArray, opts = {}) {\n  if (!this.buildPrettyMeta) throw new Error('buildPrettyMeta not defined')\n  opts.includeMeta = opts.includeMeta || null // array of meta objects to display\n  const mergedRouteArray = []\n\n  let tree = ''\n\n  routeArray.sort((a, b) => {\n    if (!a.path || !b.path) return 0\n    return a.path.localeCompare(b.path)\n  })\n\n  // merge alike paths\n  for (let i = 0; i < routeArray.length; i++) {\n    const route = routeArray[i]\n    const pathExists = mergedRouteArray.find(r => route.path === r.path)\n    if (pathExists) {\n      // path already declared, add new method and break out of loop\n      pathExists.handlers.push({\n        method: route.method,\n        opts: route.opts.constraints || undefined,\n        meta: opts.includeMeta ? buildMetaObject.call(this, route, opts.includeMeta) : null\n      })\n      continue\n    }\n\n    const routeHandler = {\n      method: route.method,\n      opts: route.opts.constraints || undefined,\n      meta: opts.includeMeta ? buildMetaObject.call(this, route, opts.includeMeta) : null\n    }\n    mergedRouteArray.push({\n      path: route.path,\n      methods: [route.method],\n      opts: [route.opts],\n      handlers: [routeHandler]\n    })\n  }\n\n  // insert root level path if none defined\n  if (!mergedRouteArray.filter(r => r.path === pathDelimiter).length) {\n    const rootPath = {\n      path: pathDelimiter,\n      truncatedPath: '',\n      methods: [],\n      opts: [],\n      handlers: [{}]\n    }\n\n    // if wildcard route exists, insert root level after wildcard\n    if (mergedRouteArray.filter(r => r.path === wildcardDelimiter).length) {\n      mergedRouteArray.splice(1, 0, rootPath)\n    } else {\n      mergedRouteArray.unshift(rootPath)\n    }\n  }\n\n  // build tree\n  const routeTree = buildRouteTree(mergedRouteArray)\n\n  // draw tree\n  routeTree.forEach((rootBranch, idx) => {\n    tree += drawBranch(rootBranch, null, idx === routeTree.length - 1, false, true)\n    tree += '\\n' // newline characters inserted at beginning of drawing function to allow for nested paths\n  })\n\n  return tree\n}\n\nfunction buildRouteTree (mergedRouteArray) {\n  const result = []\n  const temp = { result }\n  mergedRouteArray.forEach((route, idx) => {\n    let splitPath = route.path.split(pathRegExp)\n\n    // add preceding slash for proper nesting\n    if (splitPath[0] !== pathDelimiter) {\n      // handle wildcard route\n      if (splitPath[0] !== wildcardDelimiter) splitPath = [pathDelimiter, splitPath[0].slice(1), ...splitPath.slice(1)]\n    }\n\n    // build tree\n    splitPath.reduce((acc, path, pidx) => {\n      if (!acc[path]) {\n        acc[path] = { result: [] }\n        const pathSeg = { path, children: acc[path].result }\n\n        if (pidx === splitPath.length - 1) pathSeg.handlers = route.handlers\n        acc.result.push(pathSeg)\n      }\n      return acc[path]\n    }, temp)\n  })\n\n  // unfold root object from array\n  return result\n}\n\nfunction drawBranch (pathSeg, prefix, endBranch, noPrefix, rootBranch) {\n  let branch = ''\n\n  if (!noPrefix && !rootBranch) branch += '\\n'\n  if (!noPrefix) branch += `${prefix || ''}${endBranch ? endBranchIndent : midBranchIndent}`\n  branch += `${pathSeg.path}`\n\n  if (pathSeg.handlers) {\n    const flatHandlers = pathSeg.handlers.reduce((acc, curr) => {\n      const match = acc.findIndex(h => JSON.stringify(h.opts) === JSON.stringify(curr.opts))\n      if (match !== -1) {\n        acc[match].method = [acc[match].method, curr.method].join(', ')\n      } else {\n        acc.push(curr)\n      }\n      return acc\n    }, [])\n\n    flatHandlers.forEach((handler, idx) => {\n      if (idx > 0) branch += `${noPrefix ? '' : prefix || ''}${endBranch ? indent : branchIndent}${pathSeg.path}`\n      branch += ` (${handler.method || '-'})`\n      if (handler.opts && JSON.stringify(handler.opts) !== '{}') branch += ` ${JSON.stringify(handler.opts)}`\n      if (handler.meta) {\n        Reflect.ownKeys(handler.meta).forEach((m, hidx) => {\n          branch += `\\n${noPrefix ? '' : prefix || ''}${endBranch ? indent : branchIndent}`\n          branch += `• (${m}) ${JSON.stringify(handler.meta[m])}`\n        })\n      }\n      if (flatHandlers.length > 1 && idx !== flatHandlers.length - 1) branch += '\\n'\n    })\n  } else {\n    if (pathSeg.children.length > 1) branch += ' (-)'\n  }\n\n  if (!noPrefix) prefix = `${prefix || ''}${endBranch ? indent : branchIndent}`\n\n  pathSeg.children.forEach((child, idx) => {\n    const endBranch = idx === pathSeg.children.length - 1\n    const skipPrefix = (!pathSeg.handlers && pathSeg.children.length === 1)\n    branch += drawBranch(child, prefix, endBranch, skipPrefix)\n  })\n\n  return branch\n}\n\nfunction prettyPrintFlattenedNode (flattenedNode, prefix, tail, opts) {\n  if (!this.buildPrettyMeta) throw new Error('buildPrettyMeta not defined')\n  opts.includeMeta = opts.includeMeta || null // array of meta items to display\n  let paramName = ''\n  const printHandlers = []\n\n  for (const { node, method } of flattenedNode.nodes) {\n    for (const handler of node.handlerStorage.handlers) {\n      printHandlers.push({ method, ...handler })\n    }\n  }\n\n  if (printHandlers.length) {\n    printHandlers.forEach((handler, index) => {\n      let suffix = `(${handler.method || '-'})`\n      if (Object.keys(handler.constraints).length > 0) {\n        suffix += ' ' + JSON.stringify(handler.constraints)\n      }\n\n      let name = ''\n      // find locations of parameters in prefix\n      const paramIndices = flattenedNode.prefix.split('').map((ch, idx) => ch === ':' ? idx : null).filter(idx => idx !== null)\n      if (paramIndices.length) {\n        let prevLoc = 0\n        paramIndices.forEach((loc, idx) => {\n          // find parameter in prefix\n          name += flattenedNode.prefix.slice(prevLoc, loc + 1)\n          // insert parameters\n          name += handler.params[handler.params.length - paramIndices.length + idx]\n          if (idx === paramIndices.length - 1) name += flattenedNode.prefix.slice(loc + 1)\n          prevLoc = loc + 1\n        })\n      } else {\n        // there are no parameters, return full object\n        name = flattenedNode.prefix\n      }\n\n      if (index === 0) {\n        paramName += `${name} ${suffix}`\n      } else {\n        paramName += `\\n${prefix}${tail ? indent : branchIndent}${name} ${suffix}`\n      }\n      if (opts.includeMeta) {\n        const meta = buildMetaObject.call(this, handler, opts.includeMeta)\n        Object.keys(meta).forEach((m, hidx) => {\n          paramName += `\\n${prefix || ''}${tail ? indent : branchIndent}`\n          paramName += `• (${m}) ${JSON.stringify(meta[m])}`\n        })\n      }\n    })\n  } else {\n    paramName = flattenedNode.prefix\n  }\n\n  let tree = `${prefix}${tail ? endBranchIndent : midBranchIndent}${paramName}\\n`\n\n  prefix = `${prefix}${tail ? indent : branchIndent}`\n  const labels = Object.keys(flattenedNode.children)\n  for (let i = 0; i < labels.length; i++) {\n    const child = flattenedNode.children[labels[i]]\n    tree += prettyPrintFlattenedNode.call(this, child, prefix, i === (labels.length - 1), opts)\n  }\n  return tree\n}\n\nfunction flattenNode (flattened, node, method) {\n  if (node.handlerStorage.handlers.length !== 0) {\n    flattened.nodes.push({ method, node })\n  }\n\n  if (node.parametricChildren && node.parametricChildren[0]) {\n    if (!flattened.children[':']) {\n      flattened.children[':'] = {\n        prefix: ':',\n        nodes: [],\n        children: {}\n      }\n    }\n    flattenNode(flattened.children[':'], node.parametricChildren[0], method)\n  }\n\n  if (node.wildcardChild) {\n    if (!flattened.children['*']) {\n      flattened.children['*'] = {\n        prefix: '*',\n        nodes: [],\n        children: {}\n      }\n    }\n    flattenNode(flattened.children['*'], node.wildcardChild, method)\n  }\n\n  if (node.staticChildren) {\n    for (const child of Object.values(node.staticChildren)) {\n      // split on the slash separator but use a regex to lookahead and not actually match it, preserving it in the returned string segments\n      const childPrefixSegments = child.prefix.split(pathRegExp)\n      let cursor = flattened\n      let parent\n      for (const segment of childPrefixSegments) {\n        parent = cursor\n        cursor = cursor.children[segment]\n        if (!cursor) {\n          cursor = {\n            prefix: segment,\n            nodes: [],\n            children: {}\n          }\n          parent.children[segment] = cursor\n        }\n      }\n      flattenNode(cursor, child, method)\n    }\n  }\n}\n\nfunction compressFlattenedNode (flattenedNode) {\n  const childKeys = Object.keys(flattenedNode.children)\n  if (flattenedNode.nodes.length === 0 && childKeys.length === 1) {\n    const child = flattenedNode.children[childKeys[0]]\n    if (child.nodes.length <= 1) {\n      compressFlattenedNode(child)\n      flattenedNode.nodes = child.nodes\n      flattenedNode.prefix += child.prefix\n      flattenedNode.children = child.children\n      return flattenedNode\n    }\n  }\n\n  for (const key of Object.keys(flattenedNode.children)) {\n    compressFlattenedNode(flattenedNode.children[key])\n  }\n\n  return flattenedNode\n}\n\nmodule.exports = { flattenNode, compressFlattenedNode, prettyPrintFlattenedNode, prettyPrintRoutesArray }\n","'use strict'\nconst assert = require('../../assert-mock.js')\n\nfunction HostStorage () {\n  const hosts = {}\n  const regexHosts = []\n  return {\n    get: (host) => {\n      const exact = hosts[host]\n      if (exact) {\n        return exact\n      }\n      for (const regex of regexHosts) {\n        if (regex.host.test(host)) {\n          return regex.value\n        }\n      }\n    },\n    set: (host, value) => {\n      if (host instanceof RegExp) {\n        regexHosts.push({ host, value })\n      } else {\n        hosts[host] = value\n      }\n    }\n  }\n}\n\nmodule.exports = {\n  name: 'host',\n  mustMatchWhenDerived: false,\n  storage: HostStorage,\n  validate (value) {\n    assert(typeof value === 'string' || Object.prototype.toString.call(value) === '[object RegExp]', 'Host should be a string or a RegExp')\n  }\n}\n","'use strict'\n\nconst assert = require('../../assert-mock.js')\n\nfunction SemVerStore () {\n  if (!(this instanceof SemVerStore)) {\n    return new SemVerStore()\n  }\n\n  this.store = {}\n\n  this.maxMajor = 0\n  this.maxMinors = {}\n  this.maxPatches = {}\n}\n\nSemVerStore.prototype.set = function (version, store) {\n  if (typeof version !== 'string') {\n    throw new TypeError('Version should be a string')\n  }\n  let [major, minor, patch] = version.split('.')\n\n  major = Number(major) || 0\n  minor = Number(minor) || 0\n  patch = Number(patch) || 0\n\n  if (major >= this.maxMajor) {\n    this.maxMajor = major\n    this.store.x = store\n    this.store['*'] = store\n    this.store['x.x'] = store\n    this.store['x.x.x'] = store\n  }\n\n  if (minor >= (this.maxMinors[major] || 0)) {\n    this.maxMinors[major] = minor\n    this.store[`${major}.x`] = store\n    this.store[`${major}.x.x`] = store\n  }\n\n  if (patch >= (this.store[`${major}.${minor}`] || 0)) {\n    this.maxPatches[`${major}.${minor}`] = patch\n    this.store[`${major}.${minor}.x`] = store\n  }\n\n  this.store[`${major}.${minor}.${patch}`] = store\n  return this\n}\n\nSemVerStore.prototype.get = function (version) {\n  return this.store[version]\n}\n\nmodule.exports = {\n  name: 'version',\n  mustMatchWhenDerived: true,\n  storage: SemVerStore,\n  validate (value) {\n    assert(typeof value === 'string', 'Version should be a string')\n  }\n}\n","'use strict'\n\n// It must spot all the chars where decodeURIComponent(x) !== decodeURI(x)\n// The chars are: # $ & + , / : ; = ? @\nfunction decodeComponentChar (highCharCode, lowCharCode) {\n  if (highCharCode === 50) {\n    if (lowCharCode === 53) return '%'\n\n    if (lowCharCode === 51) return '#'\n    if (lowCharCode === 52) return '$'\n    if (lowCharCode === 54) return '&'\n    if (lowCharCode === 66) return '+'\n    if (lowCharCode === 98) return '+'\n    if (lowCharCode === 67) return ','\n    if (lowCharCode === 99) return ','\n    if (lowCharCode === 70) return '/'\n    if (lowCharCode === 102) return '/'\n    return null\n  }\n  if (highCharCode === 51) {\n    if (lowCharCode === 65) return ':'\n    if (lowCharCode === 97) return ':'\n    if (lowCharCode === 66) return ';'\n    if (lowCharCode === 98) return ';'\n    if (lowCharCode === 68) return '='\n    if (lowCharCode === 100) return '='\n    if (lowCharCode === 70) return '?'\n    if (lowCharCode === 102) return '?'\n    return null\n  }\n  if (highCharCode === 52 && lowCharCode === 48) {\n    return '@'\n  }\n  return null\n}\n\nfunction safeDecodeURI (path) {\n  let shouldDecode = false\n  let shouldDecodeParam = false\n\n  let querystring = ''\n\n  for (let i = 1; i < path.length; i++) {\n    const charCode = path.charCodeAt(i)\n\n    if (charCode === 37) {\n      const highCharCode = path.charCodeAt(i + 1)\n      const lowCharCode = path.charCodeAt(i + 2)\n\n      if (decodeComponentChar(highCharCode, lowCharCode) === null) {\n        shouldDecode = true\n      } else {\n        shouldDecodeParam = true\n        // %25 - encoded % char. We need to encode one more time to prevent double decoding\n        if (highCharCode === 50 && lowCharCode === 53) {\n          shouldDecode = true\n          path = path.slice(0, i + 1) + '25' + path.slice(i + 1)\n          i += 2\n        }\n        i += 2\n      }\n    // Some systems do not follow RFC and separate the path and query\n    // string with a `;` character (code 59), e.g. `/foo;jsessionid=123456`.\n    // Thus, we need to split on `;` as well as `?` and `#`.\n    } else if (charCode === 63 || charCode === 59 || charCode === 35) {\n      querystring = path.slice(i + 1)\n      path = path.slice(0, i)\n      break\n    }\n  }\n  const decodedPath = shouldDecode ? decodeURI(path) : path\n  return { path: decodedPath, querystring, shouldDecodeParam }\n}\n\nfunction safeDecodeURIComponent (uriComponent) {\n  const startIndex = uriComponent.indexOf('%')\n  if (startIndex === -1) return uriComponent\n\n  let decoded = ''\n  let lastIndex = startIndex\n\n  for (let i = startIndex; i < uriComponent.length; i++) {\n    if (uriComponent.charCodeAt(i) === 37) {\n      const highCharCode = uriComponent.charCodeAt(i + 1)\n      const lowCharCode = uriComponent.charCodeAt(i + 2)\n\n      const decodedChar = decodeComponentChar(highCharCode, lowCharCode)\n      decoded += uriComponent.slice(lastIndex, i) + decodedChar\n\n      lastIndex = i + 3\n    }\n  }\n  return uriComponent.slice(0, startIndex) + decoded + uriComponent.slice(lastIndex)\n}\n\nmodule.exports = { safeDecodeURI, safeDecodeURIComponent }\n","'use strict'\n\nvar UTF8_ACCEPT = 12\nvar UTF8_REJECT = 0\nvar UTF8_DATA = [\n  // The first part of the table maps bytes to character to a transition.\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n  4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n  5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n  6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 7, 7,\n  10, 9, 9, 9, 11, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n\n  // The second part of the table maps a state to a new state when adding a\n  // transition.\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  12, 0, 0, 0, 0, 24, 36, 48, 60, 72, 84, 96,\n  0, 12, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 24, 24, 24, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 24, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 48, 48, 48, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 48, 48, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\n  // The third part maps the current transition to a mask that needs to apply\n  // to the byte.\n  0x7F, 0x3F, 0x3F, 0x3F, 0x00, 0x1F, 0x0F, 0x0F, 0x0F, 0x07, 0x07, 0x07\n]\n\nfunction decodeURIComponent (uri) {\n  var percentPosition = uri.indexOf('%')\n  if (percentPosition === -1) return uri\n\n  var length = uri.length\n  var decoded = ''\n  var last = 0\n  var codepoint = 0\n  var startOfOctets = percentPosition\n  var state = UTF8_ACCEPT\n\n  while (percentPosition > -1 && percentPosition < length) {\n    var high = hexCodeToInt(uri[percentPosition + 1], 4)\n    var low = hexCodeToInt(uri[percentPosition + 2], 0)\n    var byte = high | low\n    var type = UTF8_DATA[byte]\n    state = UTF8_DATA[256 + state + type]\n    codepoint = (codepoint << 6) | (byte & UTF8_DATA[364 + type])\n\n    if (state === UTF8_ACCEPT) {\n      decoded += uri.slice(last, startOfOctets)\n\n      decoded += (codepoint <= 0xFFFF)\n        ? String.fromCharCode(codepoint)\n        : String.fromCharCode(\n          (0xD7C0 + (codepoint >> 10)),\n          (0xDC00 + (codepoint & 0x3FF))\n        )\n\n      codepoint = 0\n      last = percentPosition + 3\n      percentPosition = startOfOctets = uri.indexOf('%', last)\n    } else if (state === UTF8_REJECT) {\n      return null\n    } else {\n      percentPosition += 3\n      if (percentPosition < length && uri.charCodeAt(percentPosition) === 37) continue\n      return null\n    }\n  }\n\n  return decoded + uri.slice(last)\n}\n\nvar HEX = {\n  '0': 0,\n  '1': 1,\n  '2': 2,\n  '3': 3,\n  '4': 4,\n  '5': 5,\n  '6': 6,\n  '7': 7,\n  '8': 8,\n  '9': 9,\n  'a': 10,\n  'A': 10,\n  'b': 11,\n  'B': 11,\n  'c': 12,\n  'C': 12,\n  'd': 13,\n  'D': 13,\n  'e': 14,\n  'E': 14,\n  'f': 15,\n  'F': 15\n}\n\nfunction hexCodeToInt (c, shift) {\n  var i = HEX[c]\n  return i === undefined ? 255 : i << shift\n}\n\nmodule.exports = decodeURIComponent\n","'use strict';\n\n// do not edit .js files directly - edit src/index.jst\n\n\n\nmodule.exports = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n\n    var length, i, keys;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;)\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  // true if both NaN, false otherwise\n  return a!==a && b!==b;\n};\n","\"use strict\";\n\nconst parse = require(\"./parse\");\nconst stringify = require(\"./stringify\");\n\nconst fastQuerystring = {\n  parse,\n  stringify,\n};\n\n/**\n * Enable TS and JS support\n *\n * - `const qs = require('fast-querystring')`\n * - `import qs from 'fast-querystring'`\n */\nmodule.exports = fastQuerystring;\nmodule.exports.default = fastQuerystring;\nmodule.exports.parse = parse;\nmodule.exports.stringify = stringify;\n","// This file is taken from Node.js project.\n// Full implementation can be found from https://github.com/nodejs/node/blob/main/lib/internal/querystring.js\n\nconst hexTable = Array.from(\n  { length: 256 },\n  (_, i) => \"%\" + ((i < 16 ? \"0\" : \"\") + i.toString(16)).toUpperCase(),\n);\n\n// These characters do not need escaping when generating query strings:\n// ! - . _ ~\n// ' ( ) *\n// digits\n// alpha (uppercase)\n// alpha (lowercase)\n// rome-ignore format: the array should not be formatted\nconst noEscape = new Int8Array([\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0 - 15\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31\n  0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, // 32 - 47\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, // 48 - 63\n  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, // 80 - 95\n  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, // 112 - 127\n]);\n\n/**\n * @param {string} str\n * @returns {string}\n */\nfunction encodeString(str) {\n  const len = str.length;\n  if (len === 0) return \"\";\n\n  let out = \"\";\n  let lastPos = 0;\n  let i = 0;\n\n  outer: for (; i < len; i++) {\n    let c = str.charCodeAt(i);\n\n    // ASCII\n    while (c < 0x80) {\n      if (noEscape[c] !== 1) {\n        if (lastPos < i) out += str.slice(lastPos, i);\n        lastPos = i + 1;\n        out += hexTable[c];\n      }\n\n      if (++i === len) break outer;\n\n      c = str.charCodeAt(i);\n    }\n\n    if (lastPos < i) out += str.slice(lastPos, i);\n\n    // Multi-byte characters ...\n    if (c < 0x800) {\n      lastPos = i + 1;\n      out += hexTable[0xc0 | (c >> 6)] + hexTable[0x80 | (c & 0x3f)];\n      continue;\n    }\n    if (c < 0xd800 || c >= 0xe000) {\n      lastPos = i + 1;\n      out +=\n        hexTable[0xe0 | (c >> 12)] +\n        hexTable[0x80 | ((c >> 6) & 0x3f)] +\n        hexTable[0x80 | (c & 0x3f)];\n      continue;\n    }\n    // Surrogate pair\n    ++i;\n\n    // This branch should never happen because all URLSearchParams entries\n    // should already be converted to USVString. But, included for\n    // completion's sake anyway.\n    if (i >= len) {\n      throw new Error(\"URI malformed\");\n    }\n\n    const c2 = str.charCodeAt(i) & 0x3ff;\n\n    lastPos = i + 1;\n    c = 0x10000 + (((c & 0x3ff) << 10) | c2);\n    out +=\n      hexTable[0xf0 | (c >> 18)] +\n      hexTable[0x80 | ((c >> 12) & 0x3f)] +\n      hexTable[0x80 | ((c >> 6) & 0x3f)] +\n      hexTable[0x80 | (c & 0x3f)];\n  }\n  if (lastPos === 0) return str;\n  if (lastPos < len) return out + str.slice(lastPos);\n  return out;\n}\n\nmodule.exports = { encodeString };\n","\"use strict\";\n\nconst fastDecode = require(\"fast-decode-uri-component\");\n\nconst plusRegex = /\\+/g;\nconst Empty = function () {};\nEmpty.prototype = Object.create(null);\n\n/**\n * @callback parse\n * @param {string} input\n */\nfunction parse(input) {\n  // Optimization: Use new Empty() instead of Object.create(null) for performance\n  // v8 has a better optimization for initializing functions compared to Object\n  const result = new Empty();\n\n  if (typeof input !== \"string\") {\n    return result;\n  }\n\n  let inputLength = input.length;\n  let key = \"\";\n  let value = \"\";\n  let startingIndex = -1;\n  let equalityIndex = -1;\n  let shouldDecodeKey = false;\n  let shouldDecodeValue = false;\n  let keyHasPlus = false;\n  let valueHasPlus = false;\n  let hasBothKeyValuePair = false;\n  let c = 0;\n\n  // Have a boundary of input.length + 1 to access last pair inside the loop.\n  for (let i = 0; i < inputLength + 1; i++) {\n    c = i !== inputLength ? input.charCodeAt(i) : 38;\n\n    // Handle '&' and end of line to pass the current values to result\n    if (c === 38) {\n      hasBothKeyValuePair = equalityIndex > startingIndex;\n\n      // Optimization: Reuse equality index to store the end of key\n      if (!hasBothKeyValuePair) {\n        equalityIndex = i;\n      }\n\n      key = input.slice(startingIndex + 1, equalityIndex);\n\n      // Add key/value pair only if the range size is greater than 1; a.k.a. contains at least \"=\"\n      if (hasBothKeyValuePair || key.length > 0) {\n        // Optimization: Replace '+' with space\n        if (keyHasPlus) {\n          key = key.replace(plusRegex, \" \");\n        }\n\n        // Optimization: Do not decode if it's not necessary.\n        if (shouldDecodeKey) {\n          key = fastDecode(key) || key;\n        }\n\n        if (hasBothKeyValuePair) {\n          value = input.slice(equalityIndex + 1, i);\n\n          if (valueHasPlus) {\n            value = value.replace(plusRegex, \" \");\n          }\n\n          if (shouldDecodeValue) {\n            value = fastDecode(value) || value;\n          }\n        }\n        const currentValue = result[key];\n\n        if (currentValue === undefined) {\n          result[key] = value;\n        } else {\n          // Optimization: value.pop is faster than Array.isArray(value)\n          if (currentValue.pop) {\n            currentValue.push(value);\n          } else {\n            result[key] = [currentValue, value];\n          }\n        }\n      }\n\n      // Reset reading key value pairs\n      value = \"\";\n      startingIndex = i;\n      equalityIndex = i;\n      shouldDecodeKey = false;\n      shouldDecodeValue = false;\n      keyHasPlus = false;\n      valueHasPlus = false;\n    }\n    // Check '='\n    else if (c === 61) {\n      if (equalityIndex <= startingIndex) {\n        equalityIndex = i;\n      }\n      // If '=' character occurs again, we should decode the input.\n      else {\n        shouldDecodeValue = true;\n      }\n    }\n    // Check '+', and remember to replace it with empty space.\n    else if (c === 43) {\n      if (equalityIndex > startingIndex) {\n        valueHasPlus = true;\n      } else {\n        keyHasPlus = true;\n      }\n    }\n    // Check '%' character for encoding\n    else if (c === 37) {\n      if (equalityIndex > startingIndex) {\n        shouldDecodeValue = true;\n      } else {\n        shouldDecodeKey = true;\n      }\n    }\n  }\n\n  return result;\n}\n\nmodule.exports = parse;\n","\"use strict\";\n\nconst { encodeString } = require(\"./internals/querystring\");\n\nfunction getAsPrimitive(value) {\n  const type = typeof value;\n\n  if (type === \"string\") {\n    // Length check is handled inside encodeString function\n    return encodeString(value);\n  } else if (type === \"bigint\") {\n    return value.toString();\n  } else if (type === \"boolean\") {\n    return value ? \"true\" : \"false\";\n  } else if (type === \"number\" && Number.isFinite(value)) {\n    return value < 1e21 ? \"\" + value : encodeString(\"\" + value);\n  }\n\n  return \"\";\n}\n\n/**\n * @param {Record<string, string | number | boolean\n * | ReadonlyArray<string | number | boolean> | null>} input\n * @returns {string}\n */\nfunction stringify(input) {\n  let result = \"\";\n\n  if (input === null || typeof input !== \"object\") {\n    return result;\n  }\n\n  const separator = \"&\";\n  const keys = Object.keys(input);\n  const keyLength = keys.length;\n  let valueLength = 0;\n\n  for (let i = 0; i < keyLength; i++) {\n    const key = keys[i];\n    const value = input[key];\n    const encodedKey = encodeString(key) + \"=\";\n\n    if (i) {\n      result += separator;\n    }\n\n    if (Array.isArray(value)) {\n      valueLength = value.length;\n      for (let j = 0; j < valueLength; j++) {\n        if (j) {\n          result += separator;\n        }\n\n        // Optimization: Dividing into multiple lines improves the performance.\n        // Since v8 does not need to care about the '+' character if it was one-liner.\n        result += encodedKey;\n        result += getAsPrimitive(value[j]);\n      }\n    } else {\n      result += encodedKey;\n      result += getAsPrimitive(value);\n    }\n  }\n\n  return result;\n}\n\nmodule.exports = stringify;\n","const util      = require('./util');\nconst types     = require('./types');\nconst sets      = require('./sets');\nconst positions = require('./positions');\n\n\nmodule.exports = (regexpStr) => {\n  var i = 0, l, c,\n    start = { type: types.ROOT, stack: []},\n\n    // Keep track of last clause/group and stack.\n    lastGroup = start,\n    last = start.stack,\n    groupStack = [];\n\n\n  var repeatErr = (i) => {\n    util.error(regexpStr, `Nothing to repeat at column ${i - 1}`);\n  };\n\n  // Decode a few escaped characters.\n  var str = util.strToChars(regexpStr);\n  l = str.length;\n\n  // Iterate through each character in string.\n  while (i < l) {\n    c = str[i++];\n\n    switch (c) {\n      // Handle escaped characters, inclues a few sets.\n      case '\\\\':\n        c = str[i++];\n\n        switch (c) {\n          case 'b':\n            last.push(positions.wordBoundary());\n            break;\n\n          case 'B':\n            last.push(positions.nonWordBoundary());\n            break;\n\n          case 'w':\n            last.push(sets.words());\n            break;\n\n          case 'W':\n            last.push(sets.notWords());\n            break;\n\n          case 'd':\n            last.push(sets.ints());\n            break;\n\n          case 'D':\n            last.push(sets.notInts());\n            break;\n\n          case 's':\n            last.push(sets.whitespace());\n            break;\n\n          case 'S':\n            last.push(sets.notWhitespace());\n            break;\n\n          default:\n            // Check if c is integer.\n            // In which case it's a reference.\n            if (/\\d/.test(c)) {\n              last.push({ type: types.REFERENCE, value: parseInt(c, 10) });\n\n            // Escaped character.\n            } else {\n              last.push({ type: types.CHAR, value: c.charCodeAt(0) });\n            }\n        }\n\n        break;\n\n\n      // Positionals.\n      case '^':\n        last.push(positions.begin());\n        break;\n\n      case '$':\n        last.push(positions.end());\n        break;\n\n\n      // Handle custom sets.\n      case '[':\n        // Check if this class is 'anti' i.e. [^abc].\n        var not;\n        if (str[i] === '^') {\n          not = true;\n          i++;\n        } else {\n          not = false;\n        }\n\n        // Get all the characters in class.\n        var classTokens = util.tokenizeClass(str.slice(i), regexpStr);\n\n        // Increase index by length of class.\n        i += classTokens[1];\n        last.push({\n          type: types.SET,\n          set: classTokens[0],\n          not,\n        });\n\n        break;\n\n\n      // Class of any character except \\n.\n      case '.':\n        last.push(sets.anyChar());\n        break;\n\n\n      // Push group onto stack.\n      case '(':\n        // Create group.\n        var group = {\n          type: types.GROUP,\n          stack: [],\n          remember: true,\n        };\n\n        c = str[i];\n\n        // If if this is a special kind of group.\n        if (c === '?') {\n          c = str[i + 1];\n          i += 2;\n\n          // Match if followed by.\n          if (c === '=') {\n            group.followedBy = true;\n\n          // Match if not followed by.\n          } else if (c === '!') {\n            group.notFollowedBy = true;\n\n          } else if (c !== ':') {\n            util.error(regexpStr,\n              `Invalid group, character '${c}'` +\n              ` after '?' at column ${i - 1}`);\n          }\n\n          group.remember = false;\n        }\n\n        // Insert subgroup into current group stack.\n        last.push(group);\n\n        // Remember the current group for when the group closes.\n        groupStack.push(lastGroup);\n\n        // Make this new group the current group.\n        lastGroup = group;\n        last = group.stack;\n        break;\n\n\n      // Pop group out of stack.\n      case ')':\n        if (groupStack.length === 0) {\n          util.error(regexpStr, `Unmatched ) at column ${i - 1}`);\n        }\n        lastGroup = groupStack.pop();\n\n        // Check if this group has a PIPE.\n        // To get back the correct last stack.\n        last = lastGroup.options ?\n          lastGroup.options[lastGroup.options.length - 1] : lastGroup.stack;\n        break;\n\n\n      // Use pipe character to give more choices.\n      case '|':\n        // Create array where options are if this is the first PIPE\n        // in this clause.\n        if (!lastGroup.options) {\n          lastGroup.options = [lastGroup.stack];\n          delete lastGroup.stack;\n        }\n\n        // Create a new stack and add to options for rest of clause.\n        var stack = [];\n        lastGroup.options.push(stack);\n        last = stack;\n        break;\n\n\n      // Repetition.\n      // For every repetition, remove last element from last stack\n      // then insert back a RANGE object.\n      // This design is chosen because there could be more than\n      // one repetition symbols in a regex i.e. `a?+{2,3}`.\n      case '{':\n        var rs = /^(\\d+)(,(\\d+)?)?\\}/.exec(str.slice(i)), min, max;\n        if (rs !== null) {\n          if (last.length === 0) {\n            repeatErr(i);\n          }\n          min = parseInt(rs[1], 10);\n          max = rs[2] ? rs[3] ? parseInt(rs[3], 10) : Infinity : min;\n          i += rs[0].length;\n\n          last.push({\n            type: types.REPETITION,\n            min,\n            max,\n            value: last.pop(),\n          });\n        } else {\n          last.push({\n            type: types.CHAR,\n            value: 123,\n          });\n        }\n        break;\n\n      case '?':\n        if (last.length === 0) {\n          repeatErr(i);\n        }\n        last.push({\n          type: types.REPETITION,\n          min: 0,\n          max: 1,\n          value: last.pop(),\n        });\n        break;\n\n      case '+':\n        if (last.length === 0) {\n          repeatErr(i);\n        }\n        last.push({\n          type: types.REPETITION,\n          min: 1,\n          max: Infinity,\n          value: last.pop(),\n        });\n        break;\n\n      case '*':\n        if (last.length === 0) {\n          repeatErr(i);\n        }\n        last.push({\n          type: types.REPETITION,\n          min: 0,\n          max: Infinity,\n          value: last.pop(),\n        });\n        break;\n\n\n      // Default is a character that is not `\\[](){}?+*^$`.\n      default:\n        last.push({\n          type: types.CHAR,\n          value: c.charCodeAt(0),\n        });\n    }\n\n  }\n\n  // Check if any groups have not been closed.\n  if (groupStack.length !== 0) {\n    util.error(regexpStr, 'Unterminated group');\n  }\n\n  return start;\n};\n\nmodule.exports.types = types;\n","const types = require('./types');\nexports.wordBoundary = () => ({ type: types.POSITION, value: 'b' });\nexports.nonWordBoundary = () => ({ type: types.POSITION, value: 'B' });\nexports.begin = () => ({ type: types.POSITION, value: '^' });\nexports.end = () => ({ type: types.POSITION, value: '$' });\n","const types = require('./types');\n\nconst INTS = () => [{ type: types.RANGE , from: 48, to: 57 }];\n\nconst WORDS = () => {\n  return [\n    { type: types.CHAR, value: 95 },\n    { type: types.RANGE, from: 97, to: 122 },\n    { type: types.RANGE, from: 65, to: 90 }\n  ].concat(INTS());\n};\n\nconst WHITESPACE = () => {\n  return [\n    { type: types.CHAR, value: 9 },\n    { type: types.CHAR, value: 10 },\n    { type: types.CHAR, value: 11 },\n    { type: types.CHAR, value: 12 },\n    { type: types.CHAR, value: 13 },\n    { type: types.CHAR, value: 32 },\n    { type: types.CHAR, value: 160 },\n    { type: types.CHAR, value: 5760 },\n    { type: types.RANGE, from: 8192, to: 8202 },\n    { type: types.CHAR, value: 8232 },\n    { type: types.CHAR, value: 8233 },\n    { type: types.CHAR, value: 8239 },\n    { type: types.CHAR, value: 8287 },\n    { type: types.CHAR, value: 12288 },\n    { type: types.CHAR, value: 65279 }\n  ];\n};\n\nconst NOTANYCHAR = () => {\n  return [\n    { type: types.CHAR, value: 10 },\n    { type: types.CHAR, value: 13 },\n    { type: types.CHAR, value: 8232 },\n    { type: types.CHAR, value: 8233 },\n  ];\n};\n\n// Predefined class objects.\nexports.words = () => ({ type: types.SET, set: WORDS(), not: false });\nexports.notWords = () => ({ type: types.SET, set: WORDS(), not: true });\nexports.ints = () => ({ type: types.SET, set: INTS(), not: false });\nexports.notInts = () => ({ type: types.SET, set: INTS(), not: true });\nexports.whitespace = () => ({ type: types.SET, set: WHITESPACE(), not: false });\nexports.notWhitespace = () => ({ type: types.SET, set: WHITESPACE(), not: true });\nexports.anyChar = () => ({ type: types.SET, set: NOTANYCHAR(), not: true });\n","module.exports = {\n  ROOT       : 0,\n  GROUP      : 1,\n  POSITION   : 2,\n  SET        : 3,\n  RANGE      : 4,\n  REPETITION : 5,\n  REFERENCE  : 6,\n  CHAR       : 7,\n};\n","const types = require('./types');\nconst sets  = require('./sets');\n\n\nconst CTRL = '@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^ ?';\nconst SLSH = { '0': 0, 't': 9, 'n': 10, 'v': 11, 'f': 12, 'r': 13 };\n\n/**\n * Finds character representations in str and convert all to\n * their respective characters\n *\n * @param {String} str\n * @return {String}\n */\nexports.strToChars = function(str) {\n  /* jshint maxlen: false */\n  var chars_regex = /(\\[\\\\b\\])|(\\\\)?\\\\(?:u([A-F0-9]{4})|x([A-F0-9]{2})|(0?[0-7]{2})|c([@A-Z[\\\\\\]^?])|([0tnvfr]))/g;\n  str = str.replace(chars_regex, function(s, b, lbs, a16, b16, c8, dctrl, eslsh) {\n    if (lbs) {\n      return s;\n    }\n\n    var code = b ? 8 :\n      a16   ? parseInt(a16, 16) :\n      b16   ? parseInt(b16, 16) :\n      c8    ? parseInt(c8,   8) :\n      dctrl ? CTRL.indexOf(dctrl) :\n      SLSH[eslsh];\n\n    var c = String.fromCharCode(code);\n\n    // Escape special regex characters.\n    if (/[[\\]{}^$.|?*+()]/.test(c)) {\n      c = '\\\\' + c;\n    }\n\n    return c;\n  });\n\n  return str;\n};\n\n\n/**\n * turns class into tokens\n * reads str until it encounters a ] not preceeded by a \\\n *\n * @param {String} str\n * @param {String} regexpStr\n * @return {Array.<Array.<Object>, Number>}\n */\nexports.tokenizeClass = (str, regexpStr) => {\n  /* jshint maxlen: false */\n  var tokens = [];\n  var regexp = /\\\\(?:(w)|(d)|(s)|(W)|(D)|(S))|((?:(?:\\\\)(.)|([^\\]\\\\]))-(?:\\\\)?([^\\]]))|(\\])|(?:\\\\)?([^])/g;\n  var rs, c;\n\n\n  while ((rs = regexp.exec(str)) != null) {\n    if (rs[1]) {\n      tokens.push(sets.words());\n\n    } else if (rs[2]) {\n      tokens.push(sets.ints());\n\n    } else if (rs[3]) {\n      tokens.push(sets.whitespace());\n\n    } else if (rs[4]) {\n      tokens.push(sets.notWords());\n\n    } else if (rs[5]) {\n      tokens.push(sets.notInts());\n\n    } else if (rs[6]) {\n      tokens.push(sets.notWhitespace());\n\n    } else if (rs[7]) {\n      tokens.push({\n        type: types.RANGE,\n        from: (rs[8] || rs[9]).charCodeAt(0),\n        to: rs[10].charCodeAt(0),\n      });\n\n    } else if ((c = rs[12])) {\n      tokens.push({\n        type: types.CHAR,\n        value: c.charCodeAt(0),\n      });\n\n    } else {\n      return [tokens, regexp.lastIndex];\n    }\n  }\n\n  exports.error(regexpStr, 'Unterminated character class');\n};\n\n\n/**\n * Shortcut to throw errors.\n *\n * @param {String} regexp\n * @param {String} msg\n */\nexports.error = (regexp, msg) => {\n  throw new SyntaxError('Invalid regular expression: /' + regexp + '/: ' + msg);\n};\n","'use strict'\n\nvar parse = require('ret')\nvar types = parse.types\n\nmodule.exports = function (re, opts) {\n  if (!opts) opts = {}\n  var replimit = opts.limit === undefined ? 25 : opts.limit\n\n  if (isRegExp(re)) re = re.source\n  else if (typeof re !== 'string') re = String(re)\n\n  try { re = parse(re) } catch (err) { return false }\n\n  var reps = 0\n  return (function walk (node, starHeight) {\n    var i\n    var ok\n    var len\n\n    if (node.type === types.REPETITION) {\n      starHeight++\n      reps++\n      if (starHeight > 1) return false\n      if (reps > replimit) return false\n    }\n\n    if (node.options) {\n      for (i = 0, len = node.options.length; i < len; i++) {\n        ok = walk({ stack: node.options[i] }, starHeight)\n        if (!ok) return false\n      }\n    }\n    var stack = node.stack || (node.value && node.value.stack)\n    if (!stack) return true\n\n    for (i = 0; i < stack.length; i++) {\n      ok = walk(stack[i], starHeight)\n      if (!ok) return false\n    }\n\n    return true\n  })(re, 0)\n}\n\nfunction isRegExp (x) {\n  return {}.toString.call(x) === '[object RegExp]'\n}\n"]}